// src/app/api/webhooks/intakeq/route.ts
import { type NextRequest } from 'next/server';
import { NextResponse } from 'next/server';
import { GoogleSheetsService } from '@/lib/google/sheets';
import { IntakeQService } from '@/lib/intakeq/service';
import { getGoogleAuthCredentials } from '@/lib/google/auth';
import { AppointmentSyncHandler } from '@/lib/intakeq/appointment-sync';
import { EmailService } from '@/lib/email/service';

// Change runtime to nodejs
export const runtime = 'nodejs';
export const maxDuration = 300; // Increased for Node.js runtime

// Add specific memory allocation
export const memory = 1024;

export async function POST(req: NextRequest) {
  const startTime = Date.now();
  console.log(`[${new Date().toISOString()}] Starting webhook processing`);
  
  try {
    const signature = req.headers.get('X-IntakeQ-Signature');
    if (!signature) {
      console.warn('Missing signature in webhook request');
      return NextResponse.json({ 
        success: false, 
        error: 'Missing signature',
        timestamp: new Date().toISOString() 
      }, { status: 401 });
    }

    const payload = await req.json();

    console.log('Received webhook:', { 
      type: payload.EventType || payload.Type,
      clientId: payload.ClientId,
      appointmentId: payload.Appointment?.Id,
      timestamp: new Date().toISOString()
    });

    // Initialize services with better error handling
    try {
      const credentials = getGoogleAuthCredentials();
      const spreadsheetId = process.env.GOOGLE_SHEETS_SPREADSHEET_ID;
      
      if (!spreadsheetId) {
        throw new Error('Missing spreadsheet ID configuration');
      }

      const sheetsService = new GoogleSheetsService(credentials, spreadsheetId);
      console.log('Sheets service initialized');
      
      const intakeQService = new IntakeQService(
        process.env.INTAKEQ_API_KEY || '',
        sheetsService
      );
      console.log('IntakeQ service initialized');

      const emailService = new EmailService(
        process.env.SENDGRID_API_KEY || '',
        process.env.EMAIL_FROM_ADDRESS || '',
        process.env.EMAIL_FROM_NAME || '',
        sheetsService
      );
      console.log('Email service initialized');

      // Create appointment sync handler
      const syncHandler = new AppointmentSyncHandler(
        sheetsService,
        intakeQService,
        emailService
      );

      // Handle the webhook event
      const eventType = payload.EventType || payload.Type;
      
      if (!eventType) {
        console.warn('Missing event type in webhook payload');
        return NextResponse.json(
          { 
            success: false, 
            error: 'Missing event type',
            timestamp: new Date().toISOString()
          },
          { status: 400 }
        );
      }

      console.log('Processing webhook event:', eventType);

      const result = await syncHandler.processAppointmentEvent(payload);
      const processingTime = Date.now() - startTime;
      
      console.log('Webhook event processed:', {
        ...result,
        processingTime: `${processingTime}ms`
      });

      if (!result.success) {
        return NextResponse.json({
          success: false,
          error: result.error,
          details: result.details,
          processingTime,
          timestamp: new Date().toISOString()
        });
      }

      return NextResponse.json({
        success: true,
        data: result.details,
        processingTime,
        timestamp: new Date().toISOString()
      });

    } catch (serviceError) {
      console.error('Service initialization error:', serviceError);
      throw serviceError; // Re-throw to be caught by outer try-catch
    }

  } catch (error: unknown) {
    const processingTime = Date.now() - startTime;
    console.error('Webhook processing error:', {
      error,
      processingTime: `${processingTime}ms`
    });
    
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        processingTime,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

// src/lib/intakeq/service.ts
// src/lib/intakeq/service.ts

import type { IntakeQAppointment } from '@/types/webhooks';
import type { StandardOfficeId } from '@/types/scheduling';
import { GoogleSheetsService, AuditEventType } from '@/lib/google/sheets';
import { standardizeOfficeId } from '@/lib/util/office-id';
import crypto from 'crypto';

export class IntakeQService {
  private readonly baseUrl: string;
  private readonly headers: HeadersInit;
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 1000; // 1 second base delay

  constructor(
    private readonly apiKey: string,
    private readonly sheetsService: GoogleSheetsService,
    baseUrl: string = 'https://intakeq.com/api/v1',
    private readonly useMockData: boolean = false
  ) {
    this.baseUrl = baseUrl;
    this.headers = {
      'X-Auth-Key': apiKey,
      'Accept': 'application/json'
    };
  }

  async getAppointments(startDate: string, endDate: string): Promise<IntakeQAppointment[]> {
    try {
      console.log('Fetching IntakeQ appointments:', { startDate, endDate });

      // Convert dates to EST and set proper day boundaries
      const requestedStart = new Date(startDate);
      const requestedEnd = new Date(endDate);

      // Ensure we're working with EST dates
      const startEST = new Date(requestedStart.toLocaleString('en-US', { timeZone: 'America/New_York' }));
      const endEST = new Date(requestedEnd.toLocaleString('en-US', { timeZone: 'America/New_York' }));
      startEST.setHours(0, 0, 0, 0);
      endEST.setHours(23, 59, 59, 999);

      console.log('Date ranges (EST):', {
        start: startEST.toISOString(),
        end: endEST.toISOString()
      });

      const params = new URLSearchParams({
        StartDate: startEST.toISOString(),
        EndDate: endEST.toISOString(),
        Status: 'Confirmed,WaitingConfirmation,Pending',
        dateField: 'StartDateIso'
      });

      const url = `${this.baseUrl}/appointments?${params}`;

      console.log('IntakeQ Request:', {
        endpoint: '/appointments',
        params: Object.fromEntries(params),
        requestRange: {
          start: startEST.toISOString(),
          end: endEST.toISOString()
        }
      });

      let attempt = 0;
      let response;
      let lastError;

      while (attempt < this.MAX_RETRIES) {
        try {
          response = await fetch(url, {
            method: 'GET',
            headers: this.headers
          });

          if (response.ok) break;

          const errorText = await response.text();
          lastError = `HTTP ${response.status}: ${errorText}`;
          
          console.log(`Attempt ${attempt + 1} failed:`, {
            status: response.status,
            error: lastError,
            headers: Object.fromEntries(response.headers.entries()),
            url: url,
            requestHeaders: this.headers
          });

          attempt++;
          if (attempt < this.MAX_RETRIES) {
            const delay = this.RETRY_DELAY * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        } catch (error) {
          lastError = error instanceof Error ? error.message : 'Unknown error';
          console.log(`Attempt ${attempt + 1} error:`, {
            error: lastError,
            url: url,
            requestHeaders: this.headers
          });
          
          attempt++;
          if (attempt < this.MAX_RETRIES) {
            const delay = this.RETRY_DELAY * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      if (!response || !response.ok) {
        const errorMessage = `IntakeQ API error after ${this.MAX_RETRIES} attempts: ${lastError}`;
        console.error('Final error details:', {
          attempts: attempt,
          lastError,
          requestUrl: url,
          requestHeaders: this.headers
        });
        throw new Error(errorMessage);
      }

      const text = await response.text();
      console.log('Raw IntakeQ Response:', text.substring(0, 500) + '...');

      const appointments = JSON.parse(text);

      // Filter appointments to match requested date in EST
      const filteredAppointments = appointments.filter((appt: IntakeQAppointment) => {
        const apptDate = new Date(appt.StartDateIso);
        const apptEST = new Date(apptDate.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        apptEST.setHours(0, 0, 0, 0);  // Compare dates only

        const targetEST = new Date(requestedStart.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        targetEST.setHours(0, 0, 0, 0);  // Compare dates only

        console.log('Appointment comparison:', {
          id: appt.Id,
          client: appt.ClientName,
          apptDate: apptEST.toISOString(),
          targetDate: targetEST.toISOString(),
          matches: apptEST.getTime() === targetEST.getTime()
        });

        return apptEST.getTime() === targetEST.getTime();
      });

      console.log('IntakeQ Response:', {
        status: response.status,
        totalReturned: appointments.length,
        matchingDateRange: filteredAppointments.length,
        sampleAppointment: filteredAppointments[0] ? {
          id: filteredAppointments[0].Id,
          name: filteredAppointments[0].ClientName,
          date: filteredAppointments[0].StartDateLocalFormatted,
          status: filteredAppointments[0].Status
        } : null
      });

      return filteredAppointments;
    } catch (error) {
      console.error('IntakeQ API Error:', error instanceof Error ? error.message : 'Unknown error');
      
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.SYSTEM_ERROR,
        description: 'IntakeQ API error',
        user: 'SYSTEM',
        systemNotes: error instanceof Error ? error.message : 'Unknown error'
      });
      
      throw error;
    }
  }

  async validateWebhookSignature(payload: string, signature: string): Promise<boolean> {
    try {
      const secret = process.env.INTAKEQ_WEBHOOK_SECRET;
      if (!secret) {
        console.error('Missing INTAKEQ_WEBHOOK_SECRET environment variable');
        return false;
      }

      // Remove any quotes from the secret
      const cleanSecret = secret.replace(/['"]/g, '');

      // Create HMAC
      const hmac = crypto.createHmac('sha256', cleanSecret);
      hmac.update(payload);
      const calculatedSignature = hmac.digest('hex');

      console.log('Webhook Signature Validation:', {
        signatureMatches: calculatedSignature === signature,
        calculatedLength: calculatedSignature.length,
        providedLength: signature.length,
        payloadLength: payload.length,
      });

      return calculatedSignature === signature;
    } catch (error) {
      console.error('Webhook signature validation error:', error);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/practitioners`, {
        headers: this.headers
      });

      console.log('IntakeQ Connection Test:', {
        status: response.status,
        ok: response.ok
      });

      return response.ok;
    } catch (error) {
      console.error('IntakeQ connection test failed:', error instanceof Error ? error.message : 'Unknown error');
      return false;
    }
  }

  private async getStandardizedOfficeId(appointment: IntakeQAppointment): Promise<StandardOfficeId> {
    try {
      // If appointment already has an office assignment from our system, use that
      if (appointment.Location) {
        return standardizeOfficeId(appointment.Location);
      }

      // Get clinician's default office
      const clinicians = await this.sheetsService.getClinicians();
      const clinician = clinicians.find(c => c.intakeQPractitionerId === appointment.PractitionerId);

      if (clinician?.preferredOffices?.length) {
        return standardizeOfficeId(clinician.preferredOffices[0]);
      }

      // Default to A-a if no other assignment possible
      return 'A-a' as StandardOfficeId;
    } catch (error) {
      console.error('Error standardizing office ID:', error);
      return 'A-a' as StandardOfficeId;
    }
  }

  private isValidOfficeId(officeId: string): boolean {
    return /^[A-Z]-[a-z]$/.test(officeId);
  }
}

// src/lib/intakeq/webhook-handler.ts
// src/lib/intakeq/webhook-handler.ts

import type { IntakeQWebhookPayload, WebhookEventType } from '@/types/webhooks';
import type { GoogleSheetsService } from '@/lib/google/sheets';
import { AppointmentSyncHandler } from './appointment-sync';
import { AuditEventType } from '@/lib/google/sheets';

interface WebhookProcessingResult {
  success: boolean;
  error?: string;
  retryable?: boolean;
  details?: any;
}

export class EnhancedWebhookHandler {
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAYS = [1000, 5000, 15000]; // Delays in milliseconds

  constructor(
    private readonly sheetsService: GoogleSheetsService,
    private readonly appointmentSync: AppointmentSyncHandler
  ) {}

  /**
   * Get event type from payload, handling both field names
   */
  private getEventType(payload: Partial<IntakeQWebhookPayload>): WebhookEventType | undefined {
    // Use EventType if available, fall back to Type
    return payload.EventType || payload.Type;
  }

  /**
   * Process incoming webhook with validation and retries
   */
  async processWebhook(
    payload: unknown,
    signature?: string
  ): Promise<WebhookProcessingResult> {
    try {
      // Validate webhook payload
      const validationResult = this.validateWebhook(payload, signature);
      if (!validationResult.isValid) {
        await this.logWebhookError('VALIDATION_ERROR', validationResult.error || 'Unknown validation error', payload);
        return {
          success: false,
          error: validationResult.error,
          retryable: false
        };
      }

      const typedPayload = payload as IntakeQWebhookPayload;

      // Log webhook receipt
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.WEBHOOK_RECEIVED,
        description: `Received ${typedPayload.Type} webhook`,
        user: 'INTAKEQ_WEBHOOK',
        systemNotes: JSON.stringify({
          type: typedPayload.Type,
          clientId: typedPayload.ClientId
        })
      });

      // Process with retry logic
      return await this.processWithRetry(typedPayload);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      await this.logWebhookError('PROCESSING_ERROR', errorMessage, payload);
      
      return {
        success: false,
        error: errorMessage,
        retryable: this.isRetryableError(error)
      };
    }
  }

  /**
   * Validate webhook payload and signature
   */
  private validateWebhook(
    payload: unknown,
    signature?: string
  ): { isValid: boolean; error?: string } {
    // Basic payload validation
    if (!payload || typeof payload !== 'object') {
      return { isValid: false, error: 'Invalid payload format' };
    }

    const typedPayload = payload as Partial<IntakeQWebhookPayload>;

    // Required fields validation - check both Type and EventType
    const eventType = this.getEventType(typedPayload);
    if (!typedPayload.Type && !typedPayload.EventType) {
      return { isValid: false, error: 'Missing event type field' };
    }
    if (!typedPayload.ClientId) {
      return { isValid: false, error: 'Missing ClientId field' };
    }

    // Type-specific validation
    if (typedPayload.Type === 'Appointment Created' || 
        typedPayload.Type === 'Appointment Updated') {
      if (!typedPayload.Appointment) {
        return { isValid: false, error: 'Missing appointment data' };
      }

      // Validate appointment fields
      const appointment = typedPayload.Appointment;
      if (!appointment.Id || !appointment.StartDateIso || !appointment.EndDateIso) {
        return { isValid: false, error: 'Invalid appointment data' };
      }
    }

    // Signature validation if provided
    if (signature && !this.validateSignature(payload, signature)) {
      return { isValid: false, error: 'Invalid signature' };
    }

    return { isValid: true };
  }

  /**
   * Process webhook with retry logic
   */
  private async processWithRetry(
    payload: IntakeQWebhookPayload,
    attempt: number = 0
  ): Promise<WebhookProcessingResult> {
    try {
      let result: WebhookProcessingResult;
  
      const eventType = this.getEventType(payload);
      console.log('Processing event type:', eventType);

      switch (eventType) {
        case 'Appointment Created':
        case 'Appointment Updated':
        case 'AppointmentCreated':
        case 'AppointmentUpdated':
          result = await this.appointmentSync.processAppointmentEvent(payload);
          break;

        case 'Form Submitted':
        case 'Intake Submitted':
          result = await this.handleIntakeSubmission(payload);
          break;

        default:
          console.log('Unhandled event type:', {
            receivedType: eventType,
            payloadType: payload.Type,
            expectedTypes: [
              'Appointment Created',
              'Appointment Updated',
              'Form Submitted',
              'Intake Submitted'
            ]
          });
          return {
            success: false,
            error: `Unsupported webhook type: ${payload.Type}`,
            retryable: false
          };
      }

      if (!result.success && result.retryable && attempt < this.MAX_RETRIES) {
        // Log retry attempt
        await this.sheetsService.addAuditLog({
          timestamp: new Date().toISOString(),
          eventType: AuditEventType.WEBHOOK_RECEIVED,
          description: `Retry attempt ${attempt + 1} for ${payload.Type}`,
          user: 'SYSTEM',
          systemNotes: JSON.stringify({
            attempt: attempt + 1,
            type: payload.Type,
            clientId: payload.ClientId
          })
        });
        
        // Wait for delay
        await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAYS[attempt]));
        
        // Retry processing
        return this.processWithRetry(payload, attempt + 1);
      }

      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      // Log error
      await this.logWebhookError(
        'RETRY_ERROR',
        `Error on attempt ${attempt + 1}: ${errorMessage}`,
        payload
      );

      // Determine if another retry should be attempted
      if (this.isRetryableError(error) && attempt < this.MAX_RETRIES) {
        await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAYS[attempt]));
        return this.processWithRetry(payload, attempt + 1);
      }

      return {
        success: false,
        error: errorMessage,
        retryable: false
      };
    }
  }

  /**
   * Handle intake form submission
   */
  private async handleIntakeSubmission(
    payload: IntakeQWebhookPayload
  ): Promise<WebhookProcessingResult> {
    try {
      // Log initial receipt of form
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.WEBHOOK_RECEIVED,
        description: `Processing intake form ${payload.formId}`,
        user: 'INTAKEQ_WEBHOOK',
        systemNotes: JSON.stringify({
          formId: payload.formId,
          clientId: payload.ClientId,
          isFullIntake: !!payload.IntakeId
        })
      });
  
      // Ensure we have responses to process
      if (!payload.responses) {
        return {
          success: false,
          error: 'No form responses provided',
          retryable: false
        };
      }
  
      // Process responses based on form type
      const formResponses: Record<string, any> = payload.IntakeId ? 
        this.extractAccessibilitySection(payload.responses) : 
        payload.responses;
  
      // Validate processed responses
      if (Object.keys(formResponses).length === 0) {
        return {
          success: false,
          error: 'No valid accessibility responses found',
          retryable: false
        };
      }
  
      // Process form data
      await this.sheetsService.processAccessibilityForm({
        clientId: payload.ClientId.toString(),
        clientName: payload.ClientName,
        clientEmail: payload.ClientEmail,
        formResponses: formResponses
      });
  
      // Return success response
      return {
        success: true,
        details: {
          formId: payload.formId,
          clientId: payload.ClientId,
          type: payload.IntakeId ? 'full-intake' : 'accessibility-form',
          source: payload.IntakeId ? 'embedded' : 'standalone'
        }
      };
  
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      await this.logWebhookError('FORM_PROCESSING_ERROR', errorMessage, payload);
      
      return {
        success: false,
        error: errorMessage,
        retryable: this.isRetryableError(error)
      };
    }
  }

  /**
   * Determine if an error is retryable
   */
  private isRetryableError(error: unknown): boolean {
    if (error instanceof Error) {
      // Network errors are typically retryable
      if (error.message.includes('network') || error.message.includes('timeout')) {
        return true;
      }

      // API rate limiting errors are retryable
      if (error.message.includes('rate limit') || error.message.includes('429')) {
        return true;
      }

      // Temporary service errors are retryable
      if (error.message.includes('503') || error.message.includes('temporary')) {
        return true;
      }
    }

    return false;
  }

  /**
   * Validate webhook signature
   */
  private validateSignature(payload: unknown, signature: string): boolean {
    // Implement signature validation logic here
    // This would typically involve HMAC verification
    return true; // Placeholder
  }

  /**
   * Log webhook error
   */
  private async logWebhookError(
    errorType: string,
    message: string,
    payload: unknown
  ): Promise<void> {
    await this.sheetsService.addAuditLog({
      timestamp: new Date().toISOString(),
      eventType: AuditEventType.SYSTEM_ERROR,
      description: `Webhook ${errorType}: ${message}`,
      user: 'SYSTEM',
      systemNotes: JSON.stringify({
        errorType,
        payload,
        timestamp: new Date().toISOString()
      })
    });
  }

  /**
   * Log retry attempt
   */
  private extractAccessibilitySection(responses: Record<string, any>): Record<string, any> {
    // Map the accessibility questions from the full intake form
    const accessibilityResponses: Record<string, any> = {};
    
    // Define accessibility question mappings
    const questionMappings = {
      'Do you use any mobility devices?': 'mobility_devices',
      'Access needs related to mobility/disability (Please specify)': 'mobility_other',
      'Do you experience sensory sensitivities?': 'sensory_sensitivities',
      'Other (Please specify):': 'sensory_other',
      'Do you experience challenges with physical environment?': 'physical_environment',
      'Please indicate your comfort level with this possibility:': 'room_consistency',
      'Do you have support needs that involve any of the following?': 'support_needs',
      'Is there anything else we should know about your space or accessibility needs?': 'additional_notes'
    };
  
    // Extract relevant responses
    for (const [question, key] of Object.entries(questionMappings)) {
      if (responses[question] !== undefined) {
        accessibilityResponses[question] = responses[question];
      }
    }
  
    console.log('Extracted accessibility responses:', accessibilityResponses);
    
    return accessibilityResponses;
  }
}

// src/types/intakeq.ts
// src/types/intakeq.ts

// Interface for appointments from IntakeQ
export interface IntakeQAppointment {
    Id: string;
    ClientName: string;
    ClientEmail: string;
    ClientPhone: string;
    ClientDateOfBirth: string;
    ClientId: number;
    Status: string;
    StartDate: number;
    EndDate: number;
    Duration: number;
    ServiceName: string;
    ServiceId: string;
    LocationName: string;
    LocationId: string;
    Price: number;
    PractitionerName: string;
    PractitionerEmail: string;
    PractitionerId: string;
    IntakeId: string | null;
    DateCreated: number;
    CreatedBy: string;
    BookedByClient: boolean;
    ExternalClientId?: string;
    StartDateIso: string;
    EndDateIso: string;
    StartDateLocal: string;
    EndDateLocal: string;
    StartDateLocalFormatted: string;
}

// Interface for office assignment requests
export interface AssignmentRequest {
    appointment: IntakeQAppointment;
    clientPreferences?: {
        mobilityNeeds: string[];
        sensoryPreferences: string[];
        physicalNeeds: string[];
        roomConsistency: number;
        supportNeeds: string[];
    };
    requirements?: {
        accessibility?: boolean;
        specialFeatures?: string[];
    };
}

// Interface for office assignment results
export interface AssignmentResult {
    success: boolean;
    appointmentId: string;
    officeId?: string;
    error?: string;
    notes?: string;
    evaluationLog?: string[];
}

// Interface for webhook payload from IntakeQ
export interface IntakeQWebhookPayload {
    IntakeId?: string;
    Type: 'Intake Submitted' | 'Appointment Created' | 'Appointment Updated';
    ClientId: number;
    ExternalClientId?: string;
    PracticeId: string;
    ExternalPracticeId?: string | null;
    formId?: string;
    responses?: Record<string, any>;
    Appointment?: IntakeQAppointment;
    ActionPerformedByClient?: boolean;
}

// Interface for notifications about office assignments
export interface AssignmentNotification {
    type: 'assignment' | 'reassignment' | 'error';
    appointmentId: string;
    officeId?: string;
    clinicianEmail: string;
    message: string;
    changes?: {
        previousOffice?: string;
        newOffice?: string;
        reason?: string;
    };
}

// Any other types that might be in other files
// src/types/webhooks.ts

export type WebhookEventType = 
  | 'Form Submitted'
  | 'Intake Submitted'
  | 'AppointmentCreated'
  | 'AppointmentUpdated'
  | 'AppointmentRescheduled'
  | 'AppointmentCancelled'
  | 'Appointment Created'  // Keep old formats for backward compatibility
  | 'Appointment Updated'
  | 'Appointment Rescheduled'
  | 'Appointment Cancelled'
  | 'AppointmentCanceled'
  | 'Appointment Canceled'
  | 'AppointmentDeleted'
  | 'Appointment Deleted'
  | 'Form Submitted'
  | 'Intake Submitted';

export interface IntakeQAppointment {
  Id: string;
  ClientName: string;
  ClientEmail: string;
  ClientPhone: string;
  ClientDateOfBirth: string;
  ClientId: number;
  Status: string;
  StartDate: number;
  EndDate: number;
  Duration: number;
  ServiceName: string;
  ServiceId: string;
  LocationName: string;
  LocationId: string;
  Price: number;
  PractitionerName: string;
  PractitionerEmail: string;
  PractitionerId: string;
  IntakeId: string | null;
  DateCreated: number;
  CreatedBy: string;
  BookedByClient: boolean;
  ExternalClientId?: string;
  StartDateIso: string;
  EndDateIso: string;
  StartDateLocal: string;
  EndDateLocal: string;
  StartDateLocalFormatted: string;
  CancellationReason?: string;
  RecurrencePattern?: {
    frequency: 'weekly' | 'biweekly' | 'monthly';
    occurrences: number;
    endDate?: string;
  };
  [key: string]: any;
}

export interface IntakeQWebhookPayload {
  IntakeId?: string;
  Type?: WebhookEventType;  // Keep Type for backward compatibility
  EventType: WebhookEventType; // Make EventType required
  ClientId: number;
  ClientName: string;
  ClientEmail: string;
  ExternalClientId?: string;
  PracticeId: string;
  ExternalPracticeId?: string | null;
  formId?: string;
  responses?: Record<string, any>;
  Appointment?: IntakeQAppointment;
  ActionPerformedByClient?: boolean;
}

export interface WebhookResponse {
  success: boolean;
  error?: string;
  details?: any;
}

export class WebhookError extends Error {
  constructor(
    message: string,
    public readonly statusCode: number = 500,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'WebhookError';
  }
}// src/types/scheduling.ts
import type { StandardOfficeId } from './offices';

export type { StandardOfficeId };  // Re-export for backward compatibility

export type SessionType = 'in-person' | 'telehealth' | 'group' | 'family';
export type AppointmentSource = 'intakeq' | 'manual';
export type AlertSeverity = 'high' | 'medium' | 'low';

export interface AppointmentRecord {
  appointmentId: string;
  clientId: string;
  clientName: string;
  clinicianId: string;
  clinicianName: string;
  officeId: StandardOfficeId;
  suggestedOfficeId?: StandardOfficeId;
  sessionType: SessionType;
  startTime: string;
  endTime: string;
  status: 'scheduled' | 'completed' | 'cancelled' | 'rescheduled';
  lastUpdated: string;
  source: AppointmentSource;
  requirements?: {
    accessibility?: boolean;
    specialFeatures?: string[];
  };
  notes?: string;
}

export interface DailyScheduleSummary {
  date: string;
  appointments: AppointmentRecord[];
  conflicts: Array<{
    type: string;
    description: string;
    severity: AlertSeverity;
    officeId?: StandardOfficeId;
    appointmentIds?: string[];
  }>;
  alerts: Array<{
    type: string;
    message: string;
    severity: AlertSeverity;
  }>;
  officeUtilization: Map<StandardOfficeId, {
    totalSlots: number;
    bookedSlots: number;
    specialNotes?: string[];
  }>;
}

export interface SchedulingRequest {
  clientId: string;
  clinicianId: string;
  dateTime: string;
  duration: number;
  sessionType: SessionType;
  clientAge?: number;
  requirements?: {
    accessibility?: boolean;
    roomPreference?: StandardOfficeId;
    specialFeatures?: string[];
  };
}

export interface SchedulingResult {
  success: boolean;
  officeId?: StandardOfficeId;
  conflicts?: SchedulingConflict[];
  notes?: string;
  error?: string;
  evaluationLog?: string[];
}

export interface SchedulingConflict {
  officeId: StandardOfficeId;
  existingBooking: {
    clientId: string;
    clinicianId: string;
    sessionType: SessionType;
    dateTime: string;
    duration: number;
  };
  resolution?: {
    type: 'relocate' | 'cannot-relocate';
    reason: string;
    newOfficeId?: StandardOfficeId;
  };
}import type { IntakeQAppointment } from './webhooks';

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: string;
}

export interface AppointmentConflict {
  type: 'double-booking' | 'capacity' | 'accessibility';
  description: string;
  severity: 'high' | 'medium' | 'low';
  officeId?: string;
  appointmentIds?: string[];
}

export interface ValidationResponse {
  isValid: boolean;
  conflicts: AppointmentConflict[];
  error?: string;
}

export interface SchedulingResponse extends ApiResponse<{
  appointmentId: string;
  officeId?: string;
  action: string;
  conflicts?: AppointmentConflict[];
}> {}

export interface DailySyncResponse extends ApiResponse<{
  date: string;
  appointmentCount: number;
  conflicts: AppointmentConflict[];
  alerts: Array<{
    type: string;
    message: string;
    severity: 'high' | 'medium' | 'low';
  }>;
}> {}// src/types/intakeq.ts

// Interface for appointments from IntakeQ
export interface IntakeQAppointment {
    Id: string;
    ClientName: string;
    ClientEmail: string;
    ClientPhone: string;
    ClientDateOfBirth: string;
    ClientId: number;
    Status: string;
    StartDate: number;
    EndDate: number;
    Duration: number;
    ServiceName: string;
    ServiceId: string;
    LocationName: string;
    LocationId: string;
    Price: number;
    PractitionerName: string;
    PractitionerEmail: string;
    PractitionerId: string;
    IntakeId: string | null;
    DateCreated: number;
    CreatedBy: string;
    BookedByClient: boolean;
    ExternalClientId?: string;
    StartDateIso: string;
    EndDateIso: string;
    StartDateLocal: string;
    EndDateLocal: string;
    StartDateLocalFormatted: string;
}

// Interface for office assignment requests
export interface AssignmentRequest {
    appointment: IntakeQAppointment;
    clientPreferences?: {
        mobilityNeeds: string[];
        sensoryPreferences: string[];
        physicalNeeds: string[];
        roomConsistency: number;
        supportNeeds: string[];
    };
    requirements?: {
        accessibility?: boolean;
        specialFeatures?: string[];
    };
}

// Interface for office assignment results
export interface AssignmentResult {
    success: boolean;
    appointmentId: string;
    officeId?: string;
    error?: string;
    notes?: string;
    evaluationLog?: string[];
}

// Interface for webhook payload from IntakeQ
export interface IntakeQWebhookPayload {
    IntakeId?: string;
    Type: 'Intake Submitted' | 'Appointment Created' | 'Appointment Updated';
    ClientId: number;
    ExternalClientId?: string;
    PracticeId: string;
    ExternalPracticeId?: string | null;
    formId?: string;
    responses?: Record<string, any>;
    Appointment?: IntakeQAppointment;
    ActionPerformedByClient?: boolean;
}

// Interface for notifications about office assignments
export interface AssignmentNotification {
    type: 'assignment' | 'reassignment' | 'error';
    appointmentId: string;
    officeId?: string;
    clinicianEmail: string;
    message: string;
    changes?: {
        previousOffice?: string;
        newOffice?: string;
        reason?: string;
    };
}