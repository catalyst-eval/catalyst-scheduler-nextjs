// src/lib/transformations/appointment-types.ts

import type { IntakeQAppointment } from '@/types/webhooks';
import type { 
  AppointmentRecord, 
  SessionType, 
  AlertSeverity,
  StandardOfficeId 
} from '@/types/scheduling';
import { standardizeOfficeId } from '@/lib/util/office-id';

export const SESSION_TYPES = ['in-person', 'telehealth', 'group', 'family'] as const;
export const ALERT_SEVERITIES = ['high', 'medium', 'low'] as const;
export const APPOINTMENT_STATUSES = ['scheduled', 'completed', 'cancelled', 'rescheduled'] as const;

export type AppointmentStatus = typeof APPOINTMENT_STATUSES[number];
export type EmailPriority = 'high' | 'normal';

export function isSessionType(value: string): value is SessionType {
  return SESSION_TYPES.includes(value as SessionType);
}

export function isAlertSeverity(value: string): value is AlertSeverity {
  return ALERT_SEVERITIES.includes(value as AlertSeverity);
}

export function determineSessionType(serviceName: string): SessionType {
  const name = serviceName.toLowerCase();
  if (name.includes('telehealth') || name.includes('virtual')) return 'telehealth';
  if (name.includes('group')) return 'group';
  if (name.includes('family')) return 'family';
  return 'in-person';
}

export function mapAppointmentStatus(status: string): AppointmentStatus {
  const normalizedStatus = status.toLowerCase();
  switch (normalizedStatus) {
    case 'cancelled':
    case 'canceled':
      return 'cancelled';
    case 'completed':
    case 'done':
      return 'completed';
    case 'rescheduled':
      return 'rescheduled';
    default:
      return 'scheduled';
  }
}

export function mapEmailPriorityToAlertSeverity(priority: EmailPriority): AlertSeverity {
  switch (priority) {
    case 'high':
      return 'high';
    case 'normal':
      return 'medium';
  }
}

export function mapAlertSeverityToEmailPriority(severity: AlertSeverity): EmailPriority {
  switch (severity) {
    case 'high':
      return 'high';
    case 'medium':
    case 'low':
      return 'normal';
  }
}

export function transformIntakeQAppointment(appt: IntakeQAppointment): AppointmentRecord {
  return {
    appointmentId: appt.Id,
    clientId: appt.ClientId.toString(),
    clientName: appt.ClientName || appt.ClientId.toString(), // Added clientName
    clinicianId: appt.PractitionerId,
    clinicianName: appt.PractitionerName || appt.PractitionerId, // Added clinicianName
    officeId: standardizeOfficeId('A-a'),
    sessionType: determineSessionType(appt.ServiceName),
    requirements: {
      accessibility: false,
      specialFeatures: []
    },
    startTime: appt.StartDateIso,
    endTime: appt.EndDateIso,
    status: mapAppointmentStatus(appt.Status),
    lastUpdated: new Date(appt.DateCreated * 1000).toISOString(),
    source: 'intakeq' as const
  };
}// src/lib/util/office-id.ts

export type StandardOfficeId = `${Uppercase<string>}-${Lowercase<string>}`;

/**
 * Standardizes an office ID to the correct format
 * @param id The input office ID string
 * @returns A properly formatted StandardOfficeId
 */
export function standardizeOfficeId(id: string | undefined): StandardOfficeId {
  if (!id) return 'A-a' as StandardOfficeId;
  
  // Clean the input
  const cleaned = id.trim();
  
  // Check if already in correct format
  const match = cleaned.match(/^([A-Z])-([a-z])$/);
  if (match) return cleaned as StandardOfficeId;
  
  // Try to extract floor and unit
  const alphaOnly = cleaned.replace(/[^A-Za-z]/g, '');
  if (alphaOnly.length >= 2) {
    const floor = alphaOnly[0].toUpperCase();
    const unit = alphaOnly[1].toLowerCase();
    return `${floor}-${unit}` as StandardOfficeId;
  }
  
  // Return default if we can't standardize
  return 'A-a' as StandardOfficeId;
}

/**
 * Validates if a string is a proper StandardOfficeId
 * @param id The ID to validate
 * @returns boolean indicating if valid
 */
export function isValidOfficeId(id: string): boolean {
  return /^[A-Z]-[a-z]$/.test(id);
}

/**
 * Get components of a StandardOfficeId
 * @param id The StandardOfficeId to parse
 * @returns Object containing floor and unit
 */
export function parseOfficeId(id: StandardOfficeId): { floor: string; unit: string } {
  const [floor, unit] = id.split('-');
  return { floor, unit };
}

/**
 * Creates a display version of the office ID
 * @param id The StandardOfficeId to format
 * @returns Formatted string for display
 */
export function formatOfficeId(id: StandardOfficeId): string {
  const { floor, unit } = parseOfficeId(id);
  return `Floor ${floor}, Unit ${unit.toUpperCase()}`;
}import type { 
  SheetOffice, 
  AssignmentRule, 
  ClientPreference,
  SheetClinician
} from '@/types/sheets';

import type {
  SchedulingRequest,
  SchedulingResult,
  SchedulingConflict,
  StandardOfficeId
} from '@/types/scheduling';

import { standardizeOfficeId } from '../util/office-id';

interface RuleEvaluationResult {
  score: number;
  reason: string;
  log: string[];
}

interface OfficeScore {
  office: SheetOffice;
  score: number;
  reasons: string[];
  conflicts: SchedulingConflict[];
  log: string[];
}

export class OfficeAssignmentService {
  private readonly DEFAULT_OFFICE_ID = 'B-a' as StandardOfficeId;
  private readonly OFFICE_ID_PATTERN = /^[A-Z]-[a-z]$/;

  constructor(
    private readonly offices: SheetOffice[],
    private readonly rules: AssignmentRule[],
    private readonly clinicians: SheetClinician[],
    private readonly clientPreference?: ClientPreference,
    private readonly existingBookings: Map<string, SchedulingRequest[]> = new Map()
  ) {}

  async findOptimalOffice(request: SchedulingRequest): Promise<SchedulingResult> {
    const log: string[] = [`Starting office assignment for request: ${JSON.stringify(request)}`];
    
    try {
      // 1. Get clinician details
      const clinician = this.clinicians.find(c => c.clinicianId === request.clinicianId);
      if (!clinician) {
        throw new Error(`Clinician ${request.clinicianId} not found`);
      }
      log.push(`Found clinician: ${clinician.name} (${clinician.role})`);

      // 2. Filter valid offices based on basic requirements
      const validOffices = this.filterValidOffices(request, clinician);
      log.push(`Found ${validOffices.length} initially valid offices`);

      if (validOffices.length === 0) {
        // If no valid offices found, attempt to use default office
        const defaultOffice = this.offices.find(o => 
          standardizeOfficeId(o.officeId) === this.DEFAULT_OFFICE_ID
        );

        if (defaultOffice && defaultOffice.inService) {
          log.push(`No specific matches found, using default office ${this.DEFAULT_OFFICE_ID}`);
          return {
            success: true,
            officeId: this.DEFAULT_OFFICE_ID,  // Now properly typed as StandardOfficeId
            notes: 'Assigned to default office (no specific matches)',
            evaluationLog: log
          };
        }

        return {
          success: false,
          error: 'No offices match requirements and default office unavailable',
          evaluationLog: log
        };
      }

      // 3. Score each valid office
      const scoredOffices: OfficeScore[] = [];
      
      for (const office of validOffices) {
        const score = await this.scoreOffice(office, request, clinician);
        scoredOffices.push(score);
        log.push(`Scored office ${office.officeId}: ${score.score} points`);
        log.push(...score.log);
      }

      // 4. Sort by score and check for hard matches
      const hardMatches = scoredOffices.filter(score => 
        score.reasons.some(reason => reason.startsWith('HARD:'))
      );

      const candidates = hardMatches.length > 0 ? hardMatches : scoredOffices;
      candidates.sort((a, b) => b.score - a.score);

      if (candidates.length === 0) {
        return {
          success: false,
          error: 'No suitable offices found after scoring',
          evaluationLog: log
        };
      }

      const bestMatch = candidates[0];
      const standardizedOfficeId = standardizeOfficeId(bestMatch.office.officeId);
      log.push(`Selected office ${standardizedOfficeId} with score ${bestMatch.score}`);
      log.push(`Assignment reasons: ${bestMatch.reasons.join(', ')}`);

      return {
        success: true,
        officeId: standardizedOfficeId,
        conflicts: bestMatch.conflicts,
        notes: bestMatch.reasons.join('; '),
        evaluationLog: [...log, ...bestMatch.log]
      };

    } catch (error) {
      log.push(`Error in office assignment: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        evaluationLog: log
      };
    }
  }

  private filterValidOffices(
    request: SchedulingRequest,
    clinician: SheetClinician
  ): SheetOffice[] {
    const log: string[] = [];
    const validOffices: SheetOffice[] = [];
    
    try {
      for (const office of this.offices) {
        const officeId = standardizeOfficeId(office.officeId);
        let isValid = true;
        
        // Check if office is in service
        if (!office.inService) {
          log.push(`Office ${officeId} filtered: not in service`);
          isValid = false;
          continue;
        }

        // Check accessibility requirements
        if (request.requirements?.accessibility && !office.isAccessible) {
          log.push(`Office ${officeId} filtered: accessibility requirements not met`);
          isValid = false;
          continue;
        }

        // Check clinician preferences - BUT don't exclude if they're the primary clinician
        const isPrimaryClinician = office.primaryClinician === clinician.clinicianId;
        const hasPreferredOffices = clinician.preferredOffices.length > 0;
        const isPreferredOffice = clinician.preferredOffices.includes(office.officeId);

        if (!isPrimaryClinician && hasPreferredOffices && !isPreferredOffice) {
          log.push(`Office ${officeId} filtered: not in clinician's preferred offices`);
          isValid = false;
          continue;
        }

        // Check special features
        if (request.requirements?.specialFeatures?.length) {
          const hasAllFeatures = request.requirements.specialFeatures.every(
            feature => office.specialFeatures.includes(feature)
          );
          if (!hasAllFeatures) {
            log.push(`Office ${officeId} filtered: missing required features`);
            isValid = false;
            continue;
          }
        }

        // Check session type requirements
        if (request.sessionType === 'group' && !office.specialFeatures.includes('group')) {
          log.push(`Office ${officeId} filtered: not suitable for group sessions`);
          isValid = false;
          continue;
        }

        // Check room preference if specified
        if (request.requirements?.roomPreference) {
          const preferredId = standardizeOfficeId(request.requirements.roomPreference);
          if (officeId !== preferredId) {
            log.push(`Office ${officeId} filtered: not preferred room ${preferredId}`);
            isValid = false;
            continue;
          }
        }

        if (isValid) {
          validOffices.push(office);
          log.push(`Office ${officeId} passed all validation checks`);
        }
      }

      return validOffices;

    } catch (error) {
      console.error('Error filtering valid offices:', error);
      log.push(`Error during office filtering: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return [];
    }
  }

  private async scoreOffice(
    office: SheetOffice,
    request: SchedulingRequest,
    clinician: SheetClinician
  ): Promise<OfficeScore> {
    try {
      const officeId = standardizeOfficeId(office.officeId);
      const score: OfficeScore = {
        office,
        score: 0,
        reasons: [],
        conflicts: [],
        log: [`Starting evaluation for office ${officeId}`]
      };

      // 1. Check existing bookings and conflicts
      const existingBookings = this.existingBookings.get(officeId) || [];
      const timeConflicts = await this.checkTimeConflicts(request, existingBookings);
      
      if (timeConflicts.length > 0) {
        score.log.push(`Found ${timeConflicts.length} time conflicts`);
        score.conflicts = timeConflicts;
        return score;
      }

      // 2. Apply base scoring
      try {
        // Primary clinician office gets highest base score
        if (office.primaryClinician === clinician.clinicianId) {
          score.score += 1000;
          score.reasons.push('HARD: Primary clinician office');
          score.log.push('Added 1000 points: Primary clinician office');
        }
        
        // Alternative clinicians get good but lower score
        else if (office.alternativeClinicians?.includes(clinician.clinicianId)) {
          score.score += 500;
          score.reasons.push('Alternative clinician office');
          score.log.push('Added 500 points: Alternative clinician office');
        }
        
        // Preferred office bonus
        const standardizedPreferredOffices = clinician.preferredOffices.map(id => 
          standardizeOfficeId(id)
        );
        if (standardizedPreferredOffices.includes(officeId)) {
          score.score += 200;
          score.reasons.push('Clinician preferred office');
          score.log.push('Added 200 points: Clinician preferred office');
        }

        // 3. Apply rules in priority order
        const sortedRules = [...this.rules]
          .filter(rule => rule.active)
          .sort((a, b) => b.priority - a.priority); // Changed to sort highest first

        for (const rule of sortedRules) {
          const ruleScore = this.evaluateRule(rule, office, request, clinician);
          score.score += ruleScore.score;
          if (ruleScore.score > 0) {
            score.reasons.push(ruleScore.reason);
            score.log.push(...ruleScore.log);
          }
        }

        // 4. Apply client preferences if available
        if (this.clientPreference) {
          const prefScore = this.evaluateClientPreferences(office);
          score.score += prefScore.score;
          if (prefScore.score > 0) {
            score.reasons.push(...prefScore.reasons);
            score.log.push(...prefScore.log);
          }
        }

        // 5. Apply session type specific scoring
        const sessionScore = this.evaluateSessionType(office, request.sessionType);
        score.score += sessionScore.score;
        if (sessionScore.score > 0) {
          score.reasons.push(sessionScore.reason);
          score.log.push(...sessionScore.log);
        }

      } catch (error) {
        score.log.push(`Error during scoring calculations: ${error instanceof Error ? error.message : 'Unknown error'}`);
        console.error('Error calculating office score:', error);
      }

      score.log.push(`Final score for ${officeId}: ${score.score}`);
      return score;

    } catch (error) {
      console.error('Error in scoreOffice:', error);
      return {
        office,
        score: 0,
        reasons: ['Error during scoring'],
        conflicts: [],
        log: [`Error scoring office: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  private evaluateRule(
    rule: AssignmentRule,
    office: SheetOffice,
    request: SchedulingRequest,
    clinician: SheetClinician
  ): RuleEvaluationResult {
    const log: string[] = [`Evaluating rule: ${rule.ruleName}`];
    
    // Check if this rule applies to this office
    if (!rule.officeIds.includes(office.officeId)) {
      return { score: 0, reason: '', log: [`Rule ${rule.ruleName} doesn't apply to office ${office.officeId}`] };
    }

    switch (rule.ruleType) {
      case 'accessibility':
        if (request.requirements?.accessibility && office.isAccessible) {
          const score = rule.overrideLevel === 'hard' ? 1000 : 200;
          return {
            score,
            reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
            log: [`Added ${score} points for accessibility match`]
          };
        }
        break;

      case 'age_group':
        if (request.clientAge) {
          const condition = rule.condition;
          if (this.evaluateAgeCondition(condition, request.clientAge)) {
            const score = rule.overrideLevel === 'hard' ? 800 : 150;
            return {
              score,
              reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
              log: [`Added ${score} points for age group match`]
            };
          }
        }
        break;

      case 'session_type':
        if (request.sessionType === rule.condition) {
          const score = rule.overrideLevel === 'hard' ? 600 : 100;
          return {
            score,
            reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
            log: [`Added ${score} points for session type match`]
          };
        }
        break;
    }

    return { score: 0, reason: '', log: [`No points added for rule ${rule.ruleName}`] };
  }

  private evaluateClientPreferences(office: SheetOffice): {
    score: number;
    reasons: string[];
    log: string[];
  } {
    const result = {
      score: 0,
      reasons: [] as string[],
      log: ['Evaluating client preferences']
    };

    if (!this.clientPreference) {
      result.log.push('No client preferences available');
      return result;
    }

    // Check previous office assignment
    if (this.clientPreference.assignedOffice === office.officeId) {
      const roomScore = (this.clientPreference.roomConsistency || 0) * 50;
      result.score += roomScore;
      result.reasons.push('Previous office match');
      result.log.push(`Added ${roomScore} points for previous office match`);
    }

    // Safely check mobility needs
    const mobilityNeeds = this.clientPreference.mobilityNeeds || [];
    if (Array.isArray(mobilityNeeds) && mobilityNeeds.length > 0 && office.isAccessible) {
      result.score += 300;
      result.reasons.push('Meets mobility needs');
      result.log.push('Added 300 points for mobility needs match');
    }

    // Safely check sensory preferences
    const sensoryPrefs = this.clientPreference.sensoryPreferences || [];
    if (Array.isArray(sensoryPrefs) && sensoryPrefs.length > 0) {
      const matchingSensory = sensoryPrefs.filter(
        pref => office.specialFeatures.includes(pref)
      );
      if (matchingSensory.length > 0) {
        const sensoryScore = matchingSensory.length * 50;
        result.score += sensoryScore;
        result.reasons.push('Matches sensory preferences');
        result.log.push(`Added ${sensoryScore} points for sensory preference matches`);
      }
    }

    return result;
  }

  private evaluateSessionType(
    office: SheetOffice,
    sessionType: string
  ): RuleEvaluationResult {
    switch (sessionType) {
      case 'group':
        if (office.specialFeatures.includes('group')) {
          return {
            score: 200,
            reason: 'Suitable for group sessions',
            log: ['Added 200 points for group session capability']
          };
        }
        break;

      case 'family':
        if (office.size === 'large') {
          return {
            score: 150,
            reason: 'Suitable size for family sessions',
            log: ['Added 150 points for family session size']
          };
        }
        break;
    }

    return { score: 0, reason: '', log: ['No specific session type points added'] };
  }

  private evaluateAgeCondition(condition: string, age: number): boolean {
    // Handle different age condition formats
    if (condition.includes('&&')) {
      const [minStr, maxStr] = condition.split('&&');
      const minAge = parseInt(minStr.split('>')[1].trim());
      const maxAge = parseInt(maxStr.split('<=')[1].trim());
      return age > minAge && age <= maxAge;
    }
    
    if (condition.includes('<=')) {
      const maxAge = parseInt(condition.split('<=')[1].trim());
      return age <= maxAge;
    }
    
    if (condition.includes('>=')) {
      const minAge = parseInt(condition.split('>=')[1].trim());
      return age >= minAge;
    }

    return false;
  }

  private async checkTimeConflicts(
    request: SchedulingRequest,
    existingBookings: SchedulingRequest[]
  ): Promise<SchedulingConflict[]> {
    try {
      const conflicts: SchedulingConflict[] = [];
      const requestStart = new Date(request.dateTime);
      const requestEnd = new Date(requestStart.getTime() + (request.duration * 60 * 1000));

      for (const booking of existingBookings) {
        try {
          const bookingStart = new Date(booking.dateTime);
          const bookingEnd = new Date(bookingStart.getTime() + (booking.duration * 60 * 1000));

          if (requestStart < bookingEnd && requestEnd > bookingStart) {
            // Skip conflict check if both appointments are telehealth
            if (request.sessionType === 'telehealth' && booking.sessionType === 'telehealth') {
              continue;
            }

            const officeId = standardizeOfficeId(request.clinicianId);
            
            conflicts.push({
              officeId,
              existingBooking: booking,
              resolution: {
                type: 'cannot-relocate',
                reason: `Time slot overlap with existing ${booking.sessionType} session`
              }
            });
          }
        } catch (error) {
          console.error('Error processing individual booking:', error);
          continue;
        }
      }

      return conflicts;

    } catch (error) {
      console.error('Error checking time conflicts:', error);
      return [{
        officeId: standardizeOfficeId(request.clinicianId),
        existingBooking: existingBookings[0],
        resolution: {
          type: 'cannot-relocate',
          reason: 'Error checking time conflicts'
        }
      }];
    }
  }
}// src/lib/scheduling/daily-summary-service.ts

import type { 
  DailyScheduleSummary,
  AppointmentRecord,
  StandardOfficeId
} from '@/types/scheduling';
import type { SheetOffice } from '@/types/sheets';
import { standardizeOfficeId } from '@/lib/util/office-id';

export class DailySummaryService {
  constructor(
    private readonly offices: SheetOffice[],
    private readonly appointments: AppointmentRecord[]
  ) {}

  // Update Map type to use StandardOfficeId
  async generateDailySummary(date: string): Promise<DailyScheduleSummary> {
    const conflicts: DailyScheduleSummary['conflicts'] = [];
    const alerts: DailyScheduleSummary['alerts'] = [];
    const officeUtilization = new Map<StandardOfficeId, {
      totalSlots: number;
      bookedSlots: number;
      specialNotes?: string[];
    }>();

    // Standardize office IDs when initializing
    this.offices.forEach(office => {
      const standardizedId = standardizeOfficeId(office.officeId);
      const officeAppointments = this.appointments.filter(
        appt => standardizeOfficeId(appt.officeId) === standardizedId
      );

      officeUtilization.set(standardizedId, {
        totalSlots: 8,
        bookedSlots: officeAppointments.length,
        specialNotes: office.isFlexSpace ? ['Flex space - coordinate with team'] : []
      });
  
        // Check utilization
        if (officeAppointments.length / 8 > 0.9) {
          alerts.push({
            type: 'capacity',
            message: `Office ${office.officeId} is near capacity (>90% booked)`,
            severity: 'high'
          });
        }
      });
  
      // Check for conflicts
      this.offices.forEach(office => {
        const officeAppointments = this.appointments.filter(
          appt => appt.officeId === office.officeId
        );
  
        officeAppointments.forEach((appt1, i) => {
          officeAppointments.slice(i + 1).forEach(appt2 => {
            const start1 = new Date(appt1.startTime);
            const end1 = new Date(appt1.endTime);
            const start2 = new Date(appt2.startTime);
            const end2 = new Date(appt2.endTime);
  
            if (start1 < end2 && end1 > start2) {
              conflicts.push({
                type: 'double-booking',
                description: `Schedule conflict in office ${office.officeId}`,
                severity: 'high',
                officeId: standardizeOfficeId(office.officeId),
                appointmentIds: [appt1.appointmentId, appt2.appointmentId]
              });
            }
          });
        });
      });
  
      return {
        date,
        appointments: this.appointments,
        conflicts,
        alerts,
        officeUtilization
      };
    }
  }// src/lib/google/sheets.ts

import { google } from 'googleapis';
import { JWT } from 'google-auth-library';
import type { 
  SheetOffice, 
  SheetClinician, 
  AssignmentRule, 
  ClientPreference,
  ScheduleConfig,
  IntegrationSetting,
  AuditLogEntry 
} from '@/types/sheets';

import type { AppointmentRecord, StandardOfficeId } from '../../types/scheduling';
import { standardizeOfficeId } from '@/lib/util/office-id';
import { SheetsCacheService } from './sheets-cache';

export enum AuditEventType {
  CONFIG_UPDATED = 'CONFIG_UPDATED',
  RULE_CREATED = 'RULE_CREATED',
  RULE_UPDATED = 'RULE_UPDATED',
  CLIENT_PREFERENCES_UPDATED = 'CLIENT_PREFERENCES_UPDATED',
  CLIENT_OFFICE_ASSIGNED = 'CLIENT_OFFICE_ASSIGNED',
  APPOINTMENT_CREATED = 'APPOINTMENT_CREATED',
  APPOINTMENT_UPDATED = 'APPOINTMENT_UPDATED',
  APPOINTMENT_CANCELLED = 'APPOINTMENT_CANCELLED',
  APPOINTMENT_DELETED = 'APPOINTMENT_DELETED',
  SYSTEM_ERROR = 'SYSTEM_ERROR',
  WEBHOOK_RECEIVED = 'WEBHOOK_RECEIVED',
  INTEGRATION_UPDATED = 'INTEGRATION_UPDATED',
  DAILY_ASSIGNMENTS_UPDATED = 'DAILY_ASSIGNMENTS_UPDATED',
  CRITICAL_ERROR = 'CRITICAL_ERROR'
}

export class GoogleSheetsService {
  private sheets;
  private spreadsheetId: string;
  private cache: SheetsCacheService;

  constructor(credentials: any, spreadsheetId: string) {
    const client = new JWT({
      email: credentials.client_email,
      key: credentials.private_key,
      scopes: ['https://www.googleapis.com/auth/spreadsheets']
    });

    this.sheets = google.sheets({ version: 'v4', auth: client });
    this.spreadsheetId = spreadsheetId;
    this.cache = new SheetsCacheService();
  }

  private async readSheet(range: string) {
    const cacheKey = `sheet:${range}`;
    
    try {
      return await this.cache.getOrFetch(
        cacheKey,
        async () => {
          console.log(`Reading sheet range: ${range}`);
          const response = await this.sheets.spreadsheets.values.get({
            spreadsheetId: this.spreadsheetId,
            range,
          });
          return response.data.values;
        },
        60000 // 1 minute cache TTL
      );
    } catch (error) {
      console.error(`Error reading sheet ${range}:`, error);
      await this.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.SYSTEM_ERROR,
        description: `Failed to read sheet ${range}`,
        user: 'SYSTEM',
        systemNotes: JSON.stringify(error)
      });
      throw new Error(`Failed to read sheet ${range}`);
    }
  }

  private async appendRows(range: string, values: any[][]) {
    try {
      await this.sheets.spreadsheets.values.append({
        spreadsheetId: this.spreadsheetId,
        range,
        valueInputOption: 'RAW',
        requestBody: {
          values
        }
      });
    } catch (error) {
      console.error(`Error appending to sheet ${range}:`, error);
      throw error;
    }
  }

  async getOffices(): Promise<SheetOffice[]> {
    const values = await this.readSheet('Offices Configuration!A2:M');
    
    return values?.map(row => ({
      officeId: row[0],
      name: row[1],
      unit: row[2],
      inService: row[3] === 'TRUE',
      floor: row[4] as 'upstairs' | 'downstairs',
      isAccessible: row[5] === 'TRUE',
      size: row[6] as 'small' | 'medium' | 'large',
      ageGroups: row[7]?.split(',').map((s: string) => s.trim()) || [],
      specialFeatures: row[8]?.split(',').map((s: string) => s.trim()) || [],
      primaryClinician: row[9] || undefined,
      alternativeClinicians: row[10]?.split(',').map((s: string) => s.trim()) || [],
      isFlexSpace: row[11] === 'TRUE',
      notes: row[12]
    })) ?? [];
  }

  async getClinicians(): Promise<SheetClinician[]> {
    const values = await this.readSheet('Clinicians Configuration!A2:M');
    
    return values?.map(row => ({
      clinicianId: row[0],
      name: row[1],
      email: row[2],
      role: row[3] as 'owner' | 'admin' | 'clinician' | 'intern',
      ageRangeMin: Number(row[4]),
      ageRangeMax: Number(row[5]),
      specialties: row[6]?.split(',').map((s: string) => s.trim()) || [],
      caseloadLimit: Number(row[7]),
      currentCaseload: Number(row[8]),
      preferredOffices: row[9]?.split(',').map((s: string) => s.trim()) || [],
      allowsRelationship: row[10] === 'TRUE',
      certifications: row[11]?.split(',').map((s: string) => s.trim()) || [],
      intakeQPractitionerId: row[12]
    })) ?? [];
  }

  async getAssignmentRules(): Promise<AssignmentRule[]> {
    const values = await this.readSheet('Assignment Rules!A2:H');
    
    return values?.map(row => ({
      priority: Number(row[0]),
      ruleName: row[1],
      ruleType: row[2],
      condition: row[3],
      officeIds: row[4]?.split(',').map((s: string) => s.trim()) || [],
      overrideLevel: row[5] as 'hard' | 'soft' | 'none',
      active: row[6] === 'TRUE',
      notes: row[7]
    })) ?? [];
  }

  async getClientPreferences(): Promise<ClientPreference[]> {
    const values = await this.readSheet('Client Preferences!A2:L');
    
    return values?.map(row => ({
      clientId: row[0],
      name: row[1],
      email: row[2],
      mobilityNeeds: JSON.parse(row[3] || '[]'),
      sensoryPreferences: JSON.parse(row[4] || '[]'),
      physicalNeeds: JSON.parse(row[5] || '[]'),
      roomConsistency: Number(row[6]),
      supportNeeds: JSON.parse(row[7] || '[]'),
      specialFeatures: [], // Added required field with default empty array
      additionalNotes: row[8],
      lastUpdated: row[9],
      preferredClinician: row[10],
      assignedOffice: row[11]
    })) ?? [];
  }

  async getScheduleConfig(): Promise<ScheduleConfig[]> {
    const values = await this.readSheet('Schedule Configuration!A2:E');
    
    return values?.map(row => ({
      settingName: row[0],
      value: row[1],
      description: row[2],
      lastUpdated: row[3],
      updatedBy: row[4]
    })) ?? [];
  }

  async getIntegrationSettings(): Promise<IntegrationSetting[]> {
    const values = await this.readSheet('Integration Settings!A2:E');
    
    return values?.map(row => ({
      serviceName: row[0],
      settingType: row[1],
      value: row[2],
      description: row[3],
      lastUpdated: row[4]
    })) ?? [];
  }

  async addAuditLog(entry: AuditLogEntry): Promise<void> {
    try {
      const rowData = [
        entry.timestamp,
        entry.eventType,
        entry.description,
        entry.user,
        entry.previousValue || '',
        entry.newValue || '',
        entry.systemNotes || ''
      ];

      await this.appendRows('Audit Log!A:G', [rowData]);
      console.log('Audit log entry added:', entry);
    } catch (error) {
      console.error('Error adding audit log:', error);
      console.error('Failed audit log entry:', entry);
    }
  }

  async getRecentAuditLogs(limit: number = 5): Promise<AuditLogEntry[]> {
    try {
      const values = await this.readSheet('Audit Log!A2:G');
      
      if (!values) return [];
      
      if (!values || !Array.isArray(values)) {
        console.log('No appointments found in sheet');
        return [];
      }
      
      return values
        .map(row => ({
          timestamp: row[0],
          eventType: row[1],
          description: row[2],
          user: row[3],
          previousValue: row[4] || undefined,
          newValue: row[5] || undefined,
          systemNotes: row[6] || undefined
        }))
        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
        .slice(0, limit);
        
    } catch (error) {
      console.error('Error reading audit logs:', error);
      return [];
    }
  }

  async getOfficeAppointments(officeId: string, date: string): Promise<AppointmentRecord[]> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);
  
    const appointments = await this.getAppointments(
      startOfDay.toISOString(),
      endOfDay.toISOString()
    );
  
    if (officeId === 'all') {
      return appointments;
    }
  
    const standardizedTargetId = standardizeOfficeId(officeId);
    return appointments.filter(appt => standardizeOfficeId(appt.officeId) === standardizedTargetId);
  }

  async addAppointment(appt: AppointmentRecord): Promise<void> {
    try {
      const standardizedOfficeId = standardizeOfficeId(appt.officeId);
      const standardizedSuggestedId = appt.suggestedOfficeId ? 
        standardizeOfficeId(appt.suggestedOfficeId) : standardizedOfficeId;
  
      const rowData = [
        appt.appointmentId,
        appt.clientId,
        appt.clientName,
        appt.clinicianId,
        appt.clinicianName,
        standardizedOfficeId,
        appt.sessionType,
        appt.startTime,
        appt.endTime,
        appt.status,
        appt.lastUpdated,
        appt.source,
        JSON.stringify(appt.requirements || {}),
        appt.notes || '',
        standardizedSuggestedId // Column O for suggestedOfficeId
      ];
  
      await this.appendRows('Appointments!A:O', [rowData]);
  
      await this.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.APPOINTMENT_CREATED,
        description: `Added appointment ${appt.appointmentId}`,
        user: 'SYSTEM',
        systemNotes: JSON.stringify({
          ...appt,
          officeId: standardizedOfficeId,
          suggestedOfficeId: standardizedSuggestedId
        })
      });
  
      await this.refreshCache('Appointments!A2:O');
    } catch (error) {
      console.error('Error adding appointment:', error);
      throw new Error('Failed to add appointment');
    }
  }

  async getAppointments(startDate: string, endDate: string): Promise<AppointmentRecord[]> {
    try {
      const values = await this.readSheet('Appointments!A2:O');
      
      if (!values || !Array.isArray(values)) {
        console.log('No appointments found in sheet');
        return [];
      }
  
      console.log('Processing appointments from sheet:', {
        rowCount: values.length,
        dateRange: { startDate, endDate }
      });
  
      // First map and filter out nulls
      const initialAppointments = values
        .map(row => {
          try {
            // Get office IDs and standardize them
            const assignedOffice = row[5] || 'A-a';
            const suggestedOffice = row[14] || assignedOffice;
            
            const standardizedOfficeId = standardizeOfficeId(assignedOffice);
            const standardizedSuggestedId = standardizeOfficeId(suggestedOffice);
    
            // Parse requirements with error handling
            let requirements = { accessibility: false, specialFeatures: [] };
            try {
              const requirementsStr = row[12]?.toString().trim();
              if (requirementsStr) {
                const cleanJson = requirementsStr
                  .replace(/[\u0000-\u0019]+/g, '')
                  .replace(/\s+/g, ' ')
                  .trim();
                requirements = JSON.parse(cleanJson);
              }
            } catch (err) {
              console.error('Error parsing requirements JSON:', err, {value: row[12]});
            }
            
            return {
              appointmentId: row[0] || '',
              clientId: row[1] || '',
              clientName: row[2] || row[1] || '',
              clinicianId: row[3] || '',
              clinicianName: row[4] || row[3] || '',
              officeId: standardizedOfficeId,
              suggestedOfficeId: standardizedSuggestedId,
              sessionType: (row[6] || 'in-person') as 'in-person' | 'telehealth' | 'group' | 'family',
              startTime: row[7] || '',
              endTime: row[8] || '',
              status: (row[9] || 'scheduled') as 'scheduled' | 'completed' | 'cancelled' | 'rescheduled',
              lastUpdated: row[10] || new Date().toISOString(),
              source: (row[11] || 'manual') as 'intakeq' | 'manual',
              requirements,
              notes: row[13] || ''
            } as AppointmentRecord;
          } catch (error) {
            console.error('Error mapping appointment row:', error, { row });
            return null;
          }
        })
        .filter((appt): appt is AppointmentRecord => appt !== null);

      // Then filter by date
      const mappedAppointments = initialAppointments.filter(appt => {
        try {
          const apptDate = new Date(appt.startTime).toISOString().split('T')[0];
          const targetDate = new Date(startDate).toISOString().split('T')[0];
          
          console.log('Filtering appointment:', {
            id: appt.appointmentId,
            date: apptDate,
            target: targetDate,
            match: apptDate === targetDate,
            startTime: appt.startTime
          });
          
          return apptDate === targetDate;
        } catch (error) {
          console.error('Error filtering appointment:', error, { appt });
          return false;
        }
      });

      console.log('Appointment processing complete:', {
        totalFound: mappedAppointments.length,
        dateRange: { startDate, endDate }
      });

      return mappedAppointments;
    } catch (error) {
      console.error('Error reading appointments:', error);
      throw new Error('Failed to read appointments');
    }
}

  async updateAppointment(appointment: AppointmentRecord): Promise<void> {
    try {
      const values = await this.readSheet('Appointments!A:A');
      const appointmentRow = values?.findIndex(row => row[0] === appointment.appointmentId);

      if (!values || !appointmentRow || appointmentRow < 0) {
        throw new Error(`Appointment ${appointment.appointmentId} not found`);
      }

      const rowData = [
        appointment.appointmentId,
        appointment.clientId,
        appointment.clinicianId,
        appointment.officeId,
        appointment.sessionType,
        appointment.startTime,
        appointment.endTime,
        appointment.status,
        appointment.lastUpdated,
        appointment.source,
        JSON.stringify(appointment.requirements || {}),
        appointment.notes || ''
      ];

      await this.sheets.spreadsheets.values.update({
        spreadsheetId: this.spreadsheetId,
        range: `Appointments!A${appointmentRow + 1}:L${appointmentRow + 1}`,
        valueInputOption: 'RAW',
        requestBody: {
          values: [rowData]
        }
      });

      await this.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.APPOINTMENT_UPDATED,
        description: `Updated appointment ${appointment.appointmentId}`,
        user: 'SYSTEM',
        previousValue: JSON.stringify(values[appointmentRow]),
        newValue: JSON.stringify(rowData)
      });

      await this.refreshCache('Appointments!A2:N');
    } catch (error) {
      console.error('Error updating appointment:', error);
      throw new Error('Failed to update appointment');
    }
  }

  // Add after the updateAppointment method:
  async getAppointment(appointmentId: string): Promise<AppointmentRecord | null> {
    try {
      const values = await this.readSheet('Appointments!A2:N');
      if (!values) return null;
  
      const appointmentRow = values.find(row => row[0] === appointmentId);
      if (!appointmentRow) return null;
  
      return {
        appointmentId: appointmentRow[0],
        clientId: appointmentRow[1],
        clientName: appointmentRow[2],
        clinicianId: appointmentRow[3],
        clinicianName: appointmentRow[4],
        officeId: appointmentRow[5],
        sessionType: appointmentRow[6] as 'in-person' | 'telehealth' | 'group' | 'family',
        startTime: appointmentRow[7],
        endTime: appointmentRow[8],
        status: appointmentRow[9] as 'scheduled' | 'completed' | 'cancelled' | 'rescheduled',
        lastUpdated: appointmentRow[10],
        source: appointmentRow[11] as 'intakeq' | 'manual',
        requirements: JSON.parse(appointmentRow[12] || '{}'),
        notes: appointmentRow[13]
      };
    } catch (error) {
      console.error('Error getting appointment:', error);
      return null;
    }
  }


async deleteAppointment(appointmentId: string): Promise<void> {
  try {
    const values = await this.readSheet('Appointments!A:A');
    const appointmentRow = values?.findIndex(row => row[0] === appointmentId);

    if (!values || !appointmentRow || appointmentRow < 0) {
      throw new Error(`Appointment ${appointmentId} not found`);
    }

    await this.sheets.spreadsheets.values.clear({
      spreadsheetId: this.spreadsheetId,
      range: `Appointments!A${appointmentRow + 1}:L${appointmentRow + 1}`
    });

    await this.refreshCache('Appointments!A2:N');
  } catch (error) {
    console.error('Error deleting appointment:', error);
    throw new Error('Failed to delete appointment');
  }
}

  async updateClientPreference(preference: ClientPreference): Promise<void> {
    try {
      const values = await this.readSheet('Client Preferences!A:A');
      const clientRow = values?.findIndex(row => row[0] === preference.clientId);
      
      const rowData = [
        preference.clientId,
        preference.name,
        preference.email,
        JSON.stringify(preference.mobilityNeeds),
        JSON.stringify(preference.sensoryPreferences),
        JSON.stringify(preference.physicalNeeds),
        preference.roomConsistency.toString(),
        JSON.stringify(preference.supportNeeds),
        preference.additionalNotes || '',
        new Date().toISOString(),
        preference.preferredClinician || '',
        preference.assignedOffice || ''
      ];

      if (clientRow && clientRow > 0) {
        await this.sheets.spreadsheets.values.update({
          spreadsheetId: this.spreadsheetId,
          range: `Client Preferences!A${clientRow + 1}`,
          valueInputOption: 'RAW',
          requestBody: {
            values: [rowData]
          }
        });
      } else {
        await this.appendRows('Client Preferences!A:L',
          [rowData]);
        }
  
        await this.addAuditLog({
          timestamp: new Date().toISOString(),
          eventType: AuditEventType.CLIENT_PREFERENCES_UPDATED,
          description: `Updated preferences for client ${preference.clientId}`,
          user: 'SYSTEM',
          systemNotes: JSON.stringify(preference)
        });
  
        await this.refreshCache('Client Preferences!A2:L');
  
      } catch (error) {
        console.error('Error updating client preference:', error);
        throw error;
      }
    }
    
    private extractMobilityNeeds(responses: Record<string, any>): string[] {
      const needs: string[] = [];
      
      const mobilityField = responses['Do you use any mobility devices?'] || [];
      if (Array.isArray(mobilityField)) {
        if (mobilityField.includes('Wheelchair')) needs.push('wheelchair_access');
        if (mobilityField.includes('Crutches')) needs.push('mobility_aid_crutches');
        if (mobilityField.includes('Walking boot')) needs.push('mobility_aid_boot');
      }
      
      const otherMobility = responses['Access needs related to mobility/disability (Please specify)'];
      if (otherMobility) needs.push(otherMobility);
      
      return needs;
    }
    
    private extractSensoryPreferences(responses: Record<string, any>): string[] {
      const preferences: string[] = [];
      
      const sensoryField = responses['Do you experience sensory sensitivities?'] || [];
      if (Array.isArray(sensoryField)) {
        if (sensoryField.includes('Light sensitivity')) preferences.push('light_sensitive');
        if (sensoryField.includes('Preference for only natural light')) preferences.push('natural_light');
        if (sensoryField.includes('Auditory sensitivity')) preferences.push('sound_sensitive');
      }
      
      const otherSensory = responses['Other (Please specify):'];
      if (otherSensory) preferences.push(otherSensory);
      
      return preferences;
    }
    
    private extractPhysicalNeeds(responses: Record<string, any>): string[] {
      const needs: string[] = [];
      
      const physicalField = responses['Do you experience challenges with physical environment?'] || [];
      if (Array.isArray(physicalField)) {
        if (physicalField.includes('Seating support')) needs.push('seating_support');
        if (physicalField.includes('Difficulty with stairs')) needs.push('no_stairs');
        if (physicalField.includes('Need to see the door')) needs.push('door_visible');
      }
      
      return needs;
    }
    
    private extractRoomConsistency(responses: Record<string, any>): number {
      const value = responses['Please indicate your comfort level with this possibility:'];
      const consistencyMap: Record<string, number> = {
        '1 - Strong preference for consistency': 5,
        '2 - High preference for consistency': 4,
        '3 - Neutral about room changes': 3,
        '4 - Somewhat comfortable with room changes when needed': 2,
        '5 - Very comfortable with room changes when needed': 1
      };
      
      return consistencyMap[value] || 3;
    }
    
    private extractSupportNeeds(responses: Record<string, any>): string[] {
      const needs: string[] = [];
      
      const supportField = responses['Do you have support needs that involve any of the following?'] || [];
      if (Array.isArray(supportField)) {
        if (supportField.includes('Space for a service animal')) needs.push('service_animal');
        if (supportField.includes('A support person present')) needs.push('support_person');
        if (supportField.includes('The use of communication aids')) needs.push('communication_aids');
      }
      
      return needs;
    }

    async processAccessibilityForm(formData: {
      clientId: string;
      clientName: string;
      clientEmail: string;
      formResponses: Record<string, any>;
    }): Promise<void> {
      try {
        // Map form responses to client preferences structure
        const preference: ClientPreference = {
          clientId: formData.clientId,
          name: formData.clientName,
          email: formData.clientEmail,
          mobilityNeeds: this.extractMobilityNeeds(formData.formResponses),
          sensoryPreferences: this.extractSensoryPreferences(formData.formResponses),
          physicalNeeds: this.extractPhysicalNeeds(formData.formResponses),
          roomConsistency: this.extractRoomConsistency(formData.formResponses),
          supportNeeds: this.extractSupportNeeds(formData.formResponses),
          specialFeatures: [], // Will be derived from other preferences
          additionalNotes: formData.formResponses['Is there anything else we should know about your space or accessibility needs?'] || '',
          lastUpdated: new Date().toISOString(),
          preferredClinician: '',
          assignedOffice: ''
        };
    
        // Update client preferences
        await this.updateClientPreference(preference);
    
        await this.addAuditLog({
          timestamp: new Date().toISOString(),
          eventType: AuditEventType.CLIENT_PREFERENCES_UPDATED,
          description: `Processed accessibility form for client ${formData.clientId}`,
          user: 'SYSTEM',
          systemNotes: JSON.stringify(formData.formResponses)
        });
    
      } catch (error) {
        console.error('Error processing accessibility form:', error);
        await this.addAuditLog({
          timestamp: new Date().toISOString(),
          eventType: AuditEventType.SYSTEM_ERROR,
          description: `Failed to process accessibility form for client ${formData.clientId}`,
          user: 'SYSTEM',
          systemNotes: error instanceof Error ? error.message : 'Unknown error'
        });
        throw error;
      }
    }

    /**
     * Force refresh cache for a specific range
     */
    async refreshCache(range: string): Promise<void> {
      this.cache.invalidate(`sheet:${range}`);
    }
  
    /**
     * Clear all cached data
     */
    clearCache(): void {
      this.cache.clearAll();
    }
  }// src/lib/intakeq/appointment-sync.ts

import type { 
  IntakeQAppointment, 
  IntakeQWebhookPayload,
  WebhookResponse 
} from '@/types/webhooks';
import type { GoogleSheetsService } from '@/lib/google/sheets';
import type { EmailService } from '@/lib/email/service';
import type { IntakeQService } from './service';
import type { 
  SchedulingRequest,
  AppointmentRecord,
  SessionType,
  AlertSeverity,
  StandardOfficeId
} from '@/types/scheduling';
import type { 
  ValidationResponse, 
  AppointmentConflict,
  ApiResponse
} from '@/types/api';
import type { ClientPreference } from '@/types/sheets';
import { AuditEventType } from '@/lib/google/sheets';
import { OfficeAssignmentService } from '../scheduling/office-assignment';
import { EmailTemplates } from '../email/templates';
import { RecipientManagementService } from '@/lib/email/recipients';
import { 
  transformIntakeQAppointment, 
  determineSessionType,
  EmailPriority
} from '../transformations/appointment-types';
import { standardizeOfficeId } from '@/lib/util/office-id';

export class AppointmentSyncHandler {
  private readonly recipientService: RecipientManagementService;

  constructor(
    private readonly sheetsService: GoogleSheetsService,
    private readonly intakeQService: IntakeQService,
    private readonly emailService: EmailService
  ) {
    this.recipientService = new RecipientManagementService(sheetsService);
  }

  /**
   * Process appointment webhook events
   */
  async processAppointmentEvent(
    payload: IntakeQWebhookPayload
  ): Promise<WebhookResponse> {
    if (!payload.Appointment) {
      return { 
        success: false, 
        error: 'Missing appointment data' 
      };
    }

    try {
      // Log webhook receipt
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.WEBHOOK_RECEIVED,
        description: `Received ${payload.Type} webhook`,
        user: 'INTAKEQ_WEBHOOK',
        systemNotes: JSON.stringify({
          appointmentId: payload.Appointment.Id,
          type: payload.Type,
          clientId: payload.ClientId
        })
      });

      switch (payload.Type) {
        case 'AppointmentCreated':
        case 'Appointment Created':
          if (payload.Appointment.RecurrencePattern) {
            return await this.handleRecurringAppointment(
              payload.Appointment,
              payload.Appointment.RecurrencePattern
            );
          }
          return await this.handleNewAppointment(payload.Appointment);
        
        case 'AppointmentUpdated':
        case 'Appointment Updated':
        case 'AppointmentRescheduled':
        case 'Appointment Rescheduled':
          return await this.handleAppointmentUpdate(payload.Appointment);
          
        case 'AppointmentCancelled':
        case 'Appointment Cancelled':
          return await this.handleAppointmentCancellation(payload.Appointment);
          
        default:
          return {
            success: false,
            error: `Unsupported event type: ${payload.Type}`
          };
      }
    } catch (error) {
      console.error('Appointment processing error:', error);
      
      // Log the error
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.SYSTEM_ERROR,
        description: `Error processing appointment ${payload.Appointment.Id}`,
        user: 'SYSTEM',
        systemNotes: error instanceof Error ? error.message : 'Unknown error'
      });

      return {
        success: false,
        error: 'Appointment processing failed'
      };
    }
  }

  private async handleNewAppointment(
    appointment: IntakeQAppointment
  ): Promise<WebhookResponse> {
    try {
      // Convert to scheduling request format
      const request = await this.convertToSchedulingRequest(appointment);
      
      // Validate scheduling
      const validationResult = await this.validateScheduleInRealTime(request);
      if (!validationResult.isValid) {
        return {
          success: false,
          error: `Scheduling validation failed: ${validationResult.conflicts.map(c => c.description).join(', ')}`,
          details: {
            appointmentId: appointment.Id,
            action: 'validation-failed',
            conflicts: validationResult.conflicts
          }
        };
      }

      // Find optimal office
      const [offices, rules, clinicians] = await Promise.all([
        this.sheetsService.getOffices(),
        this.sheetsService.getAssignmentRules(),
        this.sheetsService.getClinicians()
      ]);

      const clientPreference = await this.getClientPreference(appointment.ClientId.toString());
      
      const assignmentService = new OfficeAssignmentService(
        offices,
        rules,
        clinicians,
        clientPreference
      );

      const assignmentResult = await assignmentService.findOptimalOffice(request);
      
      if (!assignmentResult.success) {
        throw new Error(assignmentResult.error || 'Failed to find suitable office');
      }

      // Log the assignment
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.APPOINTMENT_CREATED,
        description: `Assigned office ${assignmentResult.officeId} for appointment ${appointment.Id}`,
        user: 'SYSTEM',
        systemNotes: JSON.stringify({
          appointmentId: appointment.Id,
          officeId: assignmentResult.officeId,
          clientId: appointment.ClientId
        })
      });

      // Send notifications
      await this.sendNotifications({
        type: 'new',
        appointment,
        officeId: assignmentResult.officeId!
      });

      return {
        success: true,
        details: {
          appointmentId: appointment.Id,
          officeId: assignmentResult.officeId,
          action: 'created'
        }
      };
    } catch (error) {
      console.error('Error handling new appointment:', error);
      throw error;
    }
  }

  private async handleAppointmentUpdate(
    appointment: IntakeQAppointment
  ): Promise<WebhookResponse> {
    try {
      const request = await this.convertToSchedulingRequest(appointment);
      
      // Validate scheduling
      const validationResult = await this.validateScheduleInRealTime(request);
      if (!validationResult.isValid) {
        return {
          success: false,
          error: `Scheduling validation failed: ${validationResult.conflicts.map(c => c.description).join(', ')}`,
          details: {
            appointmentId: appointment.Id,
            action: 'validation-failed',
            conflicts: validationResult.conflicts
          }
        };
      }

      // Find optimal office for updated appointment
      const [offices, rules, clinicians] = await Promise.all([
        this.sheetsService.getOffices(),
        this.sheetsService.getAssignmentRules(),
        this.sheetsService.getClinicians()
      ]);

      const clientPreference = await this.getClientPreference(appointment.ClientId.toString());
      
      const assignmentService = new OfficeAssignmentService(
        offices,
        rules,
        clinicians,
        clientPreference
      );

      const assignmentResult = await assignmentService.findOptimalOffice(request);
      
      if (!assignmentResult.success) {
        throw new Error(assignmentResult.error || 'Failed to find suitable office');
      }

      // Log the update
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.APPOINTMENT_UPDATED,
        description: `Updated office assignment for appointment ${appointment.Id}`,
        user: 'SYSTEM',
        newValue: JSON.stringify({
          appointmentId: appointment.Id,
          officeId: assignmentResult.officeId,
          clientId: appointment.ClientId
        })
      });

      // Send notifications
      await this.sendNotifications({
        type: 'update',
        appointment,
        officeId: assignmentResult.officeId!
      });

      return {
        success: true,
        details: {
          appointmentId: appointment.Id,
          officeId: assignmentResult.officeId,
          action: 'updated'
        }
      };
    } catch (error) {
      console.error('Error handling appointment update:', error);
      throw error;
    }
  }

  private async handleAppointmentCancellation(
    appointment: IntakeQAppointment
  ): Promise<WebhookResponse> {
    try {
      // Log cancellation
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.APPOINTMENT_CANCELLED,
        description: `Cancelled appointment ${appointment.Id}`,
        user: 'SYSTEM',
        systemNotes: JSON.stringify({
          appointmentId: appointment.Id,
          clientId: appointment.ClientId,
          reason: appointment.CancellationReason || 'No reason provided'
        })
      });

      // Send notifications
      await this.sendNotifications({
        type: 'cancellation',
        appointment
      });

      return {
        success: true,
        details: {
          appointmentId: appointment.Id,
          action: 'cancelled'
        }
      };
    } catch (error) {
      console.error('Error handling appointment cancellation:', error);
      throw error;
    }
  }

  private async handleRecurringAppointment(
    appointment: IntakeQAppointment,
    recurrencePattern: {
      frequency: 'weekly' | 'biweekly' | 'monthly';
      occurrences: number;
      endDate?: string;
    }
  ): Promise<WebhookResponse> {
    try {
      let currentDate = new Date(appointment.StartDateIso);
      const endDate = recurrencePattern.endDate 
        ? new Date(recurrencePattern.endDate)
        : null;
      
      let occurrenceCount = 0;
      const results: WebhookResponse[] = [];
      
      while (
        occurrenceCount < recurrencePattern.occurrences && 
        (!endDate || currentDate <= endDate)
      ) {
        // Create appointment instance
        const instanceDate = new Date(currentDate);
        const appointmentInstance = {
          ...appointment,
          Id: `${appointment.Id}-${occurrenceCount + 1}`,
          StartDateIso: instanceDate.toISOString(),
          EndDateIso: new Date(
            instanceDate.getTime() + (appointment.Duration * 60000)
          ).toISOString()
        };

        // Process individual instance
        const result = await this.handleNewAppointment(appointmentInstance);
        results.push(result);

        if (!result.success) {
          break;
        }

        // Advance to next occurrence
        switch (recurrencePattern.frequency) {
          case 'weekly':
            currentDate.setDate(currentDate.getDate() + 7);
            break;
          case 'biweekly':
            currentDate.setDate(currentDate.getDate() + 14);
            break;
          case 'monthly':
            currentDate.setMonth(currentDate.getMonth() + 1);
            break;
        }

        occurrenceCount++;
      }

      const failedResults = results.filter(r => !r.success);
      
      if (failedResults.length > 0) {
        return {
          success: false,
          error: 'Some recurring appointments failed to schedule',
          details: {
            appointmentId: appointment.Id,
            action: 'recurring-partial',
            successful: results.length - failedResults.length,
            failed: failedResults.length,
            failures: failedResults
          }
        };
      }

      return {
        success: true,
        details: {
          appointmentId: appointment.Id,
          action: 'recurring-created',
          occurrences: results.length
        }
      };
    } catch (error) {
      console.error('Error handling recurring appointment:', error);
      throw error;
    }
  }

  // Part of appointment-sync.ts

// Part of appointment-sync.ts

private async sendNotifications(options: {
  type: 'new' | 'update' | 'cancellation';
  appointment: IntakeQAppointment;
  officeId?: StandardOfficeId;
}): Promise<void> {
  const { type, appointment, officeId } = options;

  // Get recipients based on notification type
  const recipients = await this.emailService.getClinicianRecipients();

  // Transform the appointment
  const transformedAppointment = transformIntakeQAppointment(appointment);
  
  const template = EmailTemplates.dailySchedule({
    date: new Date(appointment.StartDateIso).toISOString().split('T')[0],
    appointments: [transformedAppointment],
    alerts: [{
      type: 'appointment',
      message: `${type} appointment: ${appointment.ClientName}`,
      severity: type === 'new' ? 'low' : 'high'
    }]
  });
}

  public async validateScheduleInRealTime(
    request: SchedulingRequest
  ): Promise<ValidationResponse> {
    try {
      // Get existing appointments for the date from IntakeQ
      const requestDate = new Date(request.dateTime);
      const startOfDay = new Date(requestDate);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(requestDate);
      endOfDay.setHours(23, 59, 59, 999);

      const existingAppointments = await this.intakeQService.getAppointments(
        startOfDay.toISOString(),
        endOfDay.toISOString()
      );

      const conflicts: AppointmentConflict[] = [];

      // Check clinician availability
      const clinicianBookings = existingAppointments.filter(
        booking => booking.PractitionerId === request.clinicianId
      );

      const requestStart = new Date(request.dateTime);
      const requestEnd = new Date(
        requestStart.getTime() + (request.duration * 60000)
      );

      // Check for conflicts
      for (const booking of clinicianBookings) {
        const bookingStart = new Date(booking.StartDateIso);
        const bookingEnd = new Date(booking.EndDateIso);

        if (requestStart < bookingEnd && requestEnd > bookingStart) {
          conflicts.push({
            type: 'double-booking',
            description: 'Clinician is already booked during this time',
            severity: 'high',
            appointmentIds: [booking.Id]
          });
        }
      }

      return {
        isValid: conflicts.length === 0,
        conflicts
      };
    } catch (error) {
      console.error('Validation error:', error);
      throw error;
    }
  }

  private async getClientPreference(
    clientId: string
  ): Promise<ClientPreference | undefined> {
    const preferences = await this.sheetsService.getClientPreferences();
    return preferences.find(pref => pref.clientId === clientId);
  }

  private async convertToSchedulingRequest(
    appointment: IntakeQAppointment
  ): Promise<SchedulingRequest> {
    try {
      // Find clinician by IntakeQ ID
      const clinicians = await this.sheetsService.getClinicians();
      const clinician = clinicians.find(c => 
        c.intakeQPractitionerId === appointment.PractitionerId
      );

      if (!clinician) {
        throw new Error(`No clinician found for IntakeQ ID: ${appointment.PractitionerId}`);
      }

      // Get client preferences to determine requirements
      const clientPrefs = await this.getClientPreference(appointment.ClientId.toString());
      
      // Set base requirements from client preferences
      const mobilityNeeds = clientPrefs?.mobilityNeeds || [];
      const sensoryPrefs = clientPrefs?.sensoryPreferences || [];
      const physicalNeeds = clientPrefs?.physicalNeeds || [];

      const standardizePreferredOffice = (officeId?: string): StandardOfficeId | undefined => {
        if (!officeId) return undefined;
        return standardizeOfficeId(officeId);
      };
      
      const requirements = {
        accessibility: Array.isArray(mobilityNeeds) && mobilityNeeds.length > 0,
        specialFeatures: [
          ...(Array.isArray(sensoryPrefs) ? sensoryPrefs : []),
          ...(Array.isArray(physicalNeeds) ? physicalNeeds : [])
        ],
        roomPreference: standardizePreferredOffice(clientPrefs?.assignedOffice)  // Updated this line
      };

      return {
        clientId: appointment.ClientId.toString(),
        clinicianId: clinician.clinicianId,
        dateTime: appointment.StartDateIso,
        duration: appointment.Duration,
        sessionType: this.determineSessionType(appointment),
        requirements
      };
    } catch (error) {
      // Log conversion error
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.SYSTEM_ERROR,
        description: `Error converting IntakeQ appointment ${appointment.Id}`,
        user: 'SYSTEM',
        systemNotes: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  private determineSessionType(
    appointment: IntakeQAppointment
  ): 'in-person' | 'telehealth' | 'group' | 'family' {
    const serviceName = appointment.ServiceName.toLowerCase();
    
    // Map commonly used telehealth terms
    if (serviceName.match(/tele(health|therapy|med|session)|virtual|remote|video/)) {
      return 'telehealth';
    }
  
    // Map group therapy variations
    if (serviceName.match(/group|workshop|class|seminar/)) {
      return 'group';
    }
  
    // Map family therapy variations
    if (serviceName.match(/family|couples|relationship|parental|parent-child/)) {
      return 'family';
    }
  
    // Check service metadata if available
    if (appointment.ServiceId) {
      // Store common service IDs for quick lookup
      const TELEHEALTH_SERVICES = ['64a319db9173cb32157ea065', '64a319db9173cb32157ea066'];
      const GROUP_SERVICES = ['64a319db9173cb32157ea067'];
      const FAMILY_SERVICES = ['64a319db9173cb32157ea068'];
  
      if (TELEHEALTH_SERVICES.includes(appointment.ServiceId)) {
        return 'telehealth';
      }
      if (GROUP_SERVICES.includes(appointment.ServiceId)) {
        return 'group';
      }
      if (FAMILY_SERVICES.includes(appointment.ServiceId)) {
        return 'family';
      }
    }
  
    // Default to in-person if no other matches
    return 'in-person';
  }
}// src/lib/intakeq/service.ts

import type { IntakeQAppointment } from '@/types/webhooks';
import type { StandardOfficeId } from '@/types/scheduling';
import { GoogleSheetsService, AuditEventType } from '@/lib/google/sheets';
import { standardizeOfficeId } from '@/lib/util/office-id';
import crypto from 'crypto';

export class IntakeQService {
  private readonly baseUrl: string;
  private readonly headers: HeadersInit;
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 1000; // 1 second base delay

  constructor(
    private readonly apiKey: string,
    private readonly sheetsService: GoogleSheetsService,
    baseUrl: string = 'https://intakeq.com/api/v1',
    private readonly useMockData: boolean = false
  ) {
    this.baseUrl = baseUrl;
    this.headers = {
      'X-Auth-Key': apiKey,
      'Accept': 'application/json'
    };
  }

  async getAppointments(startDate: string, endDate: string): Promise<IntakeQAppointment[]> {
    try {
      console.log('Fetching IntakeQ appointments:', { startDate, endDate });

      // Convert dates to EST and set proper day boundaries
      const requestedStart = new Date(startDate);
      const requestedEnd = new Date(endDate);

      // Ensure we're working with EST dates
      const startEST = new Date(requestedStart.toLocaleString('en-US', { timeZone: 'America/New_York' }));
      const endEST = new Date(requestedEnd.toLocaleString('en-US', { timeZone: 'America/New_York' }));
      startEST.setHours(0, 0, 0, 0);
      endEST.setHours(23, 59, 59, 999);

      console.log('Date ranges (EST):', {
        start: startEST.toLocaleString('en-US', { timeZone: 'America/New_York' }),
        end: endEST.toLocaleString('en-US', { timeZone: 'America/New_York' })
      });

      const params = new URLSearchParams({
        StartDate: startEST.getTime().toString(),
        EndDate: endEST.getTime().toString(),
        Status: 'Confirmed,WaitingConfirmation,Pending',
        dateField: 'StartDateIso'
      });

      const url = `${this.baseUrl}/appointments?${params}`;

      console.log('IntakeQ Request:', {
        endpoint: '/appointments',
        params: Object.fromEntries(params),
        requestRange: {
          start: startEST.toLocaleString('en-US', { timeZone: 'America/New_York' }),
          end: endEST.toLocaleString('en-US', { timeZone: 'America/New_York' })
        }
      });

      let attempt = 0;
      let response;
      let lastError;

      while (attempt < this.MAX_RETRIES) {
        try {
          response = await fetch(url, {
            method: 'GET',
            headers: this.headers
          });

          if (response.ok) break;

          const errorText = await response.text();
          lastError = `HTTP ${response.status}: ${errorText}`;
          
          console.log(`Attempt ${attempt + 1} failed:`, {
            status: response.status,
            error: lastError
          });

          attempt++;
          if (attempt < this.MAX_RETRIES) {
            const delay = this.RETRY_DELAY * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        } catch (error) {
          lastError = error instanceof Error ? error.message : 'Unknown error';
          console.error(`Attempt ${attempt + 1} error:`, lastError);
          
          attempt++;
          if (attempt < this.MAX_RETRIES) {
            const delay = this.RETRY_DELAY * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      if (!response || !response.ok) {
        throw new Error(`IntakeQ API error after ${this.MAX_RETRIES} attempts: ${lastError}`);
      }

      const text = await response.text();
      console.log('Raw IntakeQ Response:', text.substring(0, 500) + '...');

      const appointments = JSON.parse(text);

      // Filter appointments to match requested date in EST
      const filteredAppointments = appointments.filter((appt: IntakeQAppointment) => {
        const apptDate = new Date(appt.StartDateIso);
        const apptEST = new Date(apptDate.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        apptEST.setHours(0, 0, 0, 0);  // Compare dates only

        const targetEST = new Date(requestedStart.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        targetEST.setHours(0, 0, 0, 0);  // Compare dates only

        console.log('Appointment comparison:', {
          id: appt.Id,
          client: appt.ClientName,
          apptDate: apptEST.toLocaleString('en-US', { timeZone: 'America/New_York' }),
          targetDate: targetEST.toLocaleString('en-US', { timeZone: 'America/New_York' }),
          matches: apptEST.getTime() === targetEST.getTime()
        });

        return apptEST.getTime() === targetEST.getTime();
      });

      console.log('IntakeQ Response:', {
        status: response.status,
        totalReturned: appointments.length,
        matchingDateRange: filteredAppointments.length,
        sampleAppointment: filteredAppointments[0] ? {
          id: filteredAppointments[0].Id,
          name: filteredAppointments[0].ClientName,
          date: filteredAppointments[0].StartDateLocalFormatted,
          status: filteredAppointments[0].Status
        } : null
      });

      return filteredAppointments;
    } catch (error) {
      console.error('IntakeQ API Error:', error instanceof Error ? error.message : 'Unknown error');
      
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.SYSTEM_ERROR,
        description: 'IntakeQ API error',
        user: 'SYSTEM',
        systemNotes: error instanceof Error ? error.message : 'Unknown error'
      });
      
      throw error;
    }
  }

  async validateWebhookSignature(payload: string, signature: string): Promise<boolean> {
    try {
      const secret = process.env.INTAKEQ_WEBHOOK_SECRET;
      if (!secret) {
        console.error('Missing INTAKEQ_WEBHOOK_SECRET environment variable');
        return false;
      }

      // Remove any quotes from the secret
      const cleanSecret = secret.replace(/['"]/g, '');

      // Create HMAC
      const hmac = crypto.createHmac('sha256', cleanSecret);
      hmac.update(payload);
      const calculatedSignature = hmac.digest('hex');

      console.log('Webhook Signature Validation:', {
        signatureMatches: calculatedSignature === signature,
        calculatedLength: calculatedSignature.length,
        providedLength: signature.length,
        payloadLength: payload.length,
      });

      return calculatedSignature === signature;
    } catch (error) {
      console.error('Webhook signature validation error:', error);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/practitioners`, {
        headers: this.headers
      });

      console.log('IntakeQ Connection Test:', {
        status: response.status,
        ok: response.ok
      });

      return response.ok;
    } catch (error) {
      console.error('IntakeQ connection test failed:', error instanceof Error ? error.message : 'Unknown error');
      return false;
    }
  }

  /**
   * Helper method to extract and standardize office ID from IntakeQ appointment
   */
  private async getStandardizedOfficeId(appointment: IntakeQAppointment): Promise<StandardOfficeId> {
    try {
      // If appointment already has an office assignment from our system, use that
      if (appointment.Location) {
        return standardizeOfficeId(appointment.Location);
      }

      // Get clinician's default office
      const clinicians = await this.sheetsService.getClinicians();
      const clinician = clinicians.find(c => c.intakeQPractitionerId === appointment.PractitionerId);

      if (clinician?.preferredOffices?.length) {
        return standardizeOfficeId(clinician.preferredOffices[0]);
      }

      // Default to A-a if no other assignment possible
      return 'A-a' as StandardOfficeId;
    } catch (error) {
      console.error('Error standardizing office ID:', error);
      return 'A-a' as StandardOfficeId;
    }
  }

  /**
   * Validate if an office ID is properly formatted
   */
  private isValidOfficeId(officeId: string): boolean {
    return /^[A-Z]-[a-z]$/.test(officeId);
  }
}