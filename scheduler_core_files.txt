// src/types/scheduling.ts

export type SessionType = 'in-person' | 'telehealth' | 'group' | 'family';
export type AppointmentSource = 'intakeq' | 'manual';
export type AlertSeverity = 'high' | 'medium' | 'low';

// Standard office ID format (e.g., 'B-a', 'A-c')
export type StandardOfficeId = `${Uppercase<string>}-${Lowercase<string>}`;

export interface AppointmentRecord {
  appointmentId: string;
  clientId: string;
  clientName: string;
  clinicianId: string;
  clinicianName: string;
  officeId: StandardOfficeId;
  suggestedOfficeId?: string;
  sessionType: SessionType;
  startTime: string;
  endTime: string;
  status: 'scheduled' | 'completed' | 'cancelled' | 'rescheduled';
  lastUpdated: string;
  source: AppointmentSource;
  requirements?: {
    accessibility?: boolean;
    specialFeatures?: string[];
  };
  notes?: string;
}

export interface DailyScheduleSummary {
  date: string;
  appointments: AppointmentRecord[];
  conflicts: Array<{
    type: string;
    description: string;
    severity: AlertSeverity;
    officeId?: StandardOfficeId;
    appointmentIds?: string[];
  }>;
  alerts: Array<{
    type: string;
    message: string;
    severity: AlertSeverity;
  }>;
  officeUtilization: Map<StandardOfficeId, {
    totalSlots: number;
    bookedSlots: number;
    specialNotes?: string[];
  }>;
}

export interface SchedulingRequest {
  clientId: string;
  clinicianId: string;
  dateTime: string;
  duration: number;
  sessionType: SessionType;
  clientAge?: number;
  requirements?: {
    accessibility?: boolean;
    roomPreference?: StandardOfficeId;
    specialFeatures?: string[];
  };
}

export interface SchedulingResult {
  success: boolean;
  officeId?: StandardOfficeId;
  conflicts?: SchedulingConflict[];
  notes?: string;
  error?: string;
  evaluationLog?: string[];
}

export interface SchedulingConflict {
  officeId: StandardOfficeId;
  existingBooking: {
    clientId: string;
    clinicianId: string;
    sessionType: SessionType;
    dateTime: string;
    duration: number;
  };
  resolution?: {
    type: 'relocate' | 'cannot-relocate';
    reason: string;
    newOfficeId?: StandardOfficeId;
  };
}

export interface TimeSlotRequest {
  officeId: StandardOfficeId;
  dateTime: string;
  duration: number;
}

export interface ValidationResult {
  isValid: boolean;
  conflicts?: string[];
  error?: string;
}// src/lib/util/office-id.ts

export type StandardOfficeId = `${Uppercase<string>}-${Lowercase<string>}`;

/**
 * Standardizes an office ID to the correct format
 * @param id The input office ID string
 * @returns A properly formatted StandardOfficeId
 */
export function standardizeOfficeId(id: string | undefined): StandardOfficeId {
  if (!id) return 'A-a' as StandardOfficeId;
  
  // Clean the input
  const cleaned = id.trim();
  
  // Check if already in correct format
  const match = cleaned.match(/^([A-Z])-([a-z])$/);
  if (match) return cleaned as StandardOfficeId;
  
  // Try to extract floor and unit
  const alphaOnly = cleaned.replace(/[^A-Za-z]/g, '');
  if (alphaOnly.length >= 2) {
    const floor = alphaOnly[0].toUpperCase();
    const unit = alphaOnly[1].toLowerCase();
    return `${floor}-${unit}` as StandardOfficeId;
  }
  
  // Return default if we can't standardize
  return 'A-a' as StandardOfficeId;
}

/**
 * Validates if a string is a proper StandardOfficeId
 * @param id The ID to validate
 * @returns boolean indicating if valid
 */
export function isValidOfficeId(id: string): boolean {
  return /^[A-Z]-[a-z]$/.test(id);
}

/**
 * Get components of a StandardOfficeId
 * @param id The StandardOfficeId to parse
 * @returns Object containing floor and unit
 */
export function parseOfficeId(id: StandardOfficeId): { floor: string; unit: string } {
  const [floor, unit] = id.split('-');
  return { floor, unit };
}

/**
 * Creates a display version of the office ID
 * @param id The StandardOfficeId to format
 * @returns Formatted string for display
 */
export function formatOfficeId(id: StandardOfficeId): string {
  const { floor, unit } = parseOfficeId(id);
  return `Floor ${floor}, Unit ${unit.toUpperCase()}`;
}// src/lib/scheduling/daily-assignment-service.ts

import { toEST, getESTDayRange, isSameESTDay } from '../util/date-helpers';
import type { 
  AppointmentRecord,
  SchedulingConflict,
  StandardOfficeId
} from '@/types/scheduling';
import { standardizeOfficeId } from '../util/office-id';
import type { 
  SheetOffice, 
  SheetClinician, 
  ClientPreference
} from '@/types/sheets';

import { GoogleSheetsService, AuditEventType } from '@/lib/google/sheets';
import type { IntakeQService } from '@/lib/intakeq/service';
import { OfficeAssignmentService } from './office-assignment';

interface DailyScheduleSummary {
  date: string;
  appointments: AppointmentRecord[];
  conflicts: Array<{
    type: 'double-booking' | 'accessibility' | 'capacity';
    description: string;
    severity: 'high' | 'medium' | 'low';
    officeId?: StandardOfficeId;
    appointmentIds?: string[];
  }>;
  officeUtilization: Map<StandardOfficeId, {
    totalSlots: number;
    bookedSlots: number;
    specialNotes?: string[];
  }>;
  alerts: Array<{
    type: 'accessibility' | 'capacity' | 'scheduling' | 'system';
    message: string;
    severity: 'high' | 'medium' | 'low';
  }>;
}

export class DailyAssignmentService {
  constructor(
    private readonly sheetsService: GoogleSheetsService,
    private readonly intakeQService: IntakeQService
  ) {}

  private getTomorrowDate(): string {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    return tomorrow.toISOString().split('T')[0];
  }
  
  async generateTomorrowSummary(): Promise<DailyScheduleSummary> {
    return this.generateDailySummary(this.getTomorrowDate());
  }

  async generateDailySummary(date: string): Promise<DailyScheduleSummary> {
    try {
      console.log('Generating daily summary for:', date);
      
      // Get date range in EST
      const range = getESTDayRange(date);
const startOfDay = range.start;
const endOfDay = range.end;
      
      console.log('Date range for summary:', {
        requestedDate: date,
        startOfDay,
        endOfDay,
        estDate: toEST(date).toLocaleString('en-US', { timeZone: 'America/New_York' })
      });

      // Fetch all required data
      console.log('Fetching data...');
      const [intakeQAppointments, offices, clinicians, clientPreferences, localAppointments] = await Promise.all([
        this.intakeQService.getAppointments(startOfDay, endOfDay),
        this.sheetsService.getOffices(),
        this.sheetsService.getClinicians(),
        this.sheetsService.getClientPreferences(),
        this.sheetsService.getAppointments(startOfDay, endOfDay)
      ]);

      console.log('Found appointments:', {
        intakeQ: intakeQAppointments.length,
        local: localAppointments.length
      });

      // Create lookup maps
      const clinicianMap = new Map(
        clinicians.map(c => [c.intakeQPractitionerId, c]) // Map practitioner ID to clinician object
      );

      // Process appointments
console.log('Processing IntakeQ appointments...');
const processedIntakeQAppointments = await Promise.all(intakeQAppointments.map(async intakeQAppt => {
  // Get local appointment if exists
  const localAppt = localAppointments.find(appt => appt.appointmentId === intakeQAppt.Id);
  const clinician = clinicianMap.get(intakeQAppt.PractitionerId);

  // Get suggested office from local appointment or calculate new one
  let suggestedOfficeId = localAppt?.suggestedOfficeId;
  let officeId = localAppt?.officeId;
  let notes = localAppt?.notes;

  if (!suggestedOfficeId && clinician) {
    const assignmentService = new OfficeAssignmentService(
      offices,
      await this.sheetsService.getAssignmentRules(),
      clinicians
    );

    const result = await assignmentService.findOptimalOffice({
      clientId: intakeQAppt.ClientId.toString(),
      clinicianId: clinician.clinicianId,
      dateTime: intakeQAppt.StartDateIso,
      duration: this.calculateDuration(intakeQAppt.StartDateIso, intakeQAppt.EndDateIso),
      sessionType: this.determineSessionType(intakeQAppt.ServiceName)
    });

    if (result.success) {
      suggestedOfficeId = result.officeId;
      officeId = result.officeId;
      notes = result.notes;
    }
  }
  
  // Use imported standardizeOfficeId utility
  const standardizedOfficeId = standardizeOfficeId(officeId || 'A-a');
  const standardizedSuggestedId = standardizeOfficeId(suggestedOfficeId);
  
  return {
    appointmentId: intakeQAppt.Id,
    clientId: intakeQAppt.ClientId.toString(),
    clientName: intakeQAppt.ClientName,
    clinicianId: clinicianMap.get(intakeQAppt.PractitionerId)?.clinicianId || intakeQAppt.PractitionerId,
    clinicianName: clinicianMap.get(intakeQAppt.PractitionerId)?.name || 'Unknown',
    officeId: standardizedOfficeId,
    suggestedOfficeId: standardizedSuggestedId,
    sessionType: this.determineSessionType(intakeQAppt.ServiceName),
    startTime: intakeQAppt.StartDateIso,
    endTime: intakeQAppt.EndDateIso,
    status: localAppt?.status || 'scheduled',
    lastUpdated: new Date().toISOString(),
    source: localAppt?.source || 'intakeq' as 'intakeq' | 'manual',
    requirements: localAppt?.requirements || {
      accessibility: false,
      specialFeatures: []
    },
    notes
  };
}));

      // Sort appointments by time
      // Process local appointments that aren't from IntakeQ
      console.log('Processing local appointments...');
      const localOnlyAppointments = localAppointments.filter(
        local => !intakeQAppointments.some(intakeQ => intakeQ.Id === local.appointmentId)
      );

      console.log('Appointment counts:', {
        intakeQ: processedIntakeQAppointments.length,
        localOnly: localOnlyAppointments.length
      });

      // Combine all appointments
      const allAppointments = [...processedIntakeQAppointments, ...localOnlyAppointments];

      // Sort appointments by time
      allAppointments.sort((a, b) => {
        if (a.clinicianName < b.clinicianName) return -1;
        if (a.clinicianName > b.clinicianName) return 1;
        return new Date(a.startTime).getTime() - new Date(b.startTime).getTime();
      });

      // Create summary
      const summary: DailyScheduleSummary = {
        date,
        appointments: allAppointments,
        conflicts: [],
        officeUtilization: new Map(),
        alerts: []
      };

      // Process conflicts and generate alerts
      this.processAppointments(summary, allAppointments, offices, clinicians, clientPreferences);
      this.calculateOfficeUtilization(summary, offices);
      this.generateAlerts(summary);

      // Log summary
      await this.sheetsService.addAuditLog({
        timestamp: new Date().toISOString(),
        eventType: AuditEventType.DAILY_ASSIGNMENTS_UPDATED,
        description: `Generated daily summary for ${date}`,
        user: 'SYSTEM',
        systemNotes: JSON.stringify({
          appointmentCount: allAppointments.length,
          conflictCount: summary.conflicts.length,
          alertCount: summary.alerts.length
        })
      });

      console.log('Final summary:', {
        date,
        totalAppointments: summary.appointments.length,
        intakeQCount: processedIntakeQAppointments.length,
        localCount: localOnlyAppointments.length,
        conflicts: summary.conflicts.length,
        alerts: summary.alerts.length,
        sampleAppointments: summary.appointments.slice(0, 2).map(appt => ({
          id: appt.appointmentId,
          client: appt.clientName,
          time: appt.startTime
        }))
      });

      return summary;
    } catch (error) {
      console.error('Error generating daily summary:', error);
      throw error;
    }
  }

  private calculateDuration(startTime: string, endTime: string): number {
    const start = new Date(startTime);
    const end = new Date(endTime);
    return Math.round((end.getTime() - start.getTime()) / (60 * 1000));
  }

  private determineSessionType(serviceName: string): 'in-person' | 'telehealth' | 'group' | 'family' {
    const name = serviceName.toLowerCase();
    if (name.includes('telehealth') || name.includes('virtual')) return 'telehealth';
    if (name.includes('group')) return 'group';
    if (name.includes('family') || name.includes('relationship')) return 'family';
    return 'in-person';
  }

  private processAppointments(
    summary: DailyScheduleSummary,
    appointments: AppointmentRecord[],
    offices: SheetOffice[],
    clinicians: SheetClinician[],
    clientPreferences: ClientPreference[]
  ): void {
    appointments.forEach((appt1, i) => {
      // Check for overlapping appointments
      appointments.slice(i + 1).forEach(appt2 => {
        // Only check for overlaps if appointments are on the same day
        const sameDay = isSameESTDay(appt1.startTime, appt2.startTime);
        
        if (sameDay && this.appointmentsOverlap(appt1, appt2)) {
          // Skip telehealth appointments from conflict detection
          if (appt1.sessionType === 'telehealth' || appt2.sessionType === 'telehealth') {
            return;
          }
          
          // Check for same office conflicts
          if (appt1.officeId === appt2.officeId) {
            summary.conflicts.push({
              type: 'double-booking',
              description: `Schedule conflict in ${appt1.officeId}: ${appt1.clientName || appt1.clientId} and ${appt2.clientName || appt2.clientId}`,
              severity: 'high',
              officeId: appt1.officeId,
              appointmentIds: [appt1.appointmentId, appt2.appointmentId]
            });
          }
    
          // Check for clinician double-booking
          if (appt1.clinicianId === appt2.clinicianId) {
            summary.conflicts.push({
              type: 'double-booking',
              description: `${appt1.clinicianName || appt1.clinicianId} has overlapping appointments`,
              severity: 'high',
              appointmentIds: [appt1.appointmentId, appt2.appointmentId]
            });
          }
        }
      });
      // Check for overlapping appointments
      appointments.slice(i + 1).forEach(appt2 => {
        if (this.appointmentsOverlap(appt1, appt2)) {
          if (appt1.officeId === appt2.officeId) {
            summary.conflicts.push({
              type: 'double-booking',
              description: `Schedule conflict in ${appt1.officeId}: ${appt1.clientName} and ${appt2.clientName}`,
              severity: 'high',
              officeId: appt1.officeId,
              appointmentIds: [appt1.appointmentId, appt2.appointmentId]
            });
          }

          if (appt1.clinicianId === appt2.clinicianId) {
            summary.conflicts.push({
              type: 'double-booking',
              description: `${appt1.clinicianName} has overlapping appointments`,
              severity: 'high',
              appointmentIds: [appt1.appointmentId, appt2.appointmentId]
            });
          }
        }
      });

      // Check accessibility requirements
      const clientPref = clientPreferences.find(
        pref => pref.clientId === appt1.clientId
      );
      const office = offices.find(
        office => office.officeId === appt1.officeId
      );

      if (clientPref?.mobilityNeeds.length && office && !office.isAccessible) {
        summary.conflicts.push({
          type: 'accessibility',
          description: `${appt1.clientName} requires accessible office but assigned to ${appt1.officeId}`,
          severity: 'high',
          officeId: this.standardizeOfficeId(appt1.officeId),
          appointmentIds: [appt1.appointmentId]
        });
      }
    });
  }

  private standardizeOfficeId(id: string): StandardOfficeId {
    const match = id.match(/^([A-Z])-([a-z])$/);
    if (match) return id as StandardOfficeId;
    return 'A-a' as StandardOfficeId;
  }

  private calculateOfficeUtilization(
    summary: DailyScheduleSummary,
    offices: SheetOffice[]
  ): void {
    offices.forEach(office => {
      const standardizedOfficeId = standardizeOfficeId(office.officeId);
      const officeAppointments = summary.appointments.filter(
        appt => standardizeOfficeId(appt.officeId) === standardizedOfficeId
      );
  
      const totalSlots = 8; // 8-hour day
      const bookedSlots = officeAppointments.length;
  
      const notes: string[] = [];
      if (office.isFlexSpace) {
        notes.push('Flex space - coordinate with team');
      }
      if (bookedSlots / totalSlots > 0.9) {
        notes.push('Critical capacity warning');
      } else if (bookedSlots / totalSlots > 0.8) {
        notes.push('High utilization');
      }
  
      summary.officeUtilization.set(standardizedOfficeId, {
        totalSlots,
        bookedSlots,
        specialNotes: notes
      });
    });
  }

  private appointmentsOverlap(appt1: AppointmentRecord, appt2: AppointmentRecord): boolean {
    // Convert times to minutes since midnight for easier comparison
    const getMinutes = (time: string) => {
      const date = new Date(time);
      return date.getUTCHours() * 60 + date.getUTCMinutes();
    };
  
    const start1 = getMinutes(appt1.startTime);
    const end1 = start1 + this.getDurationMinutes(appt1.startTime, appt1.endTime);
    const start2 = getMinutes(appt2.startTime);
    const end2 = start2 + this.getDurationMinutes(appt2.startTime, appt2.endTime);
  
    console.log('Checking overlap:', {
      appt1: {
        id: appt1.appointmentId,
        client: appt1.clientName || appt1.clientId,
        start: start1,
        end: end1,
        time: new Date(appt1.startTime).toLocaleString()
      },
      appt2: {
        id: appt2.appointmentId,
        client: appt2.clientName || appt2.clientId,
        start: start2,
        end: end2,
        time: new Date(appt2.startTime).toLocaleString()
      }
    });
  
    // Check actual overlap
    return start1 < end2 && end1 > start2;
  }
  
  private getDurationMinutes(startTime: string, endTime: string): number {
    const start = new Date(startTime);
    const end = new Date(endTime);
    return Math.round((end.getTime() - start.getTime()) / (60 * 1000));
  }

  private generateAlerts(summary: DailyScheduleSummary): void {
    // Check high priority conflicts
    const highPriorityConflicts = summary.conflicts.filter(
      conflict => conflict.severity === 'high'
    );

    if (highPriorityConflicts.length > 0) {
      summary.alerts.push({
        type: 'scheduling',
        message: `${highPriorityConflicts.length} high-priority conflicts detected`,
        severity: 'high'
      });
    }

    // Check office capacity
    const highCapacityOffices = Array.from(summary.officeUtilization.entries())
      .filter(([_, data]) => data.bookedSlots / data.totalSlots > 0.8);

    if (highCapacityOffices.length > 0) {
      summary.alerts.push({
        type: 'capacity',
        message: `${highCapacityOffices.length} offices are at high capacity`,
        severity: 'medium'
      });
    }
  }
}import type { 
  SheetOffice, 
  AssignmentRule, 
  ClientPreference,
  SheetClinician
} from '@/types/sheets';

import type {
  SchedulingRequest,
  SchedulingResult,
  SchedulingConflict,
  StandardOfficeId
} from '@/types/scheduling';

interface RuleEvaluationResult {
  score: number;
  reason: string;
  log: string[];
}

interface OfficeScore {
  office: SheetOffice;
  score: number;
  reasons: string[];
  conflicts: SchedulingConflict[];
  log: string[];
}

export class OfficeAssignmentService {
  private readonly DEFAULT_OFFICE_ID = 'B-a' as StandardOfficeId;
  private readonly OFFICE_ID_PATTERN = /^[A-Z]-[a-z]$/;

  constructor(
    private readonly offices: SheetOffice[],
    private readonly rules: AssignmentRule[],
    private readonly clinicians: SheetClinician[],
    private readonly clientPreference?: ClientPreference,
    private readonly existingBookings: Map<string, SchedulingRequest[]> = new Map()
  ) {}

  /**
   * Standardize office ID format
   */
  private standardizeOfficeId(officeId: string): StandardOfficeId {
    // Remove any whitespace
    const cleanId = officeId.trim();

    // If it already matches pattern, return as is
    if (this.OFFICE_ID_PATTERN.test(cleanId)) {
      return cleanId as StandardOfficeId;
    }

    // Try to extract floor and unit
    const floor = cleanId.charAt(0).toUpperCase();
    const unit = cleanId.slice(-1).toLowerCase();

    // If we can construct a valid ID, return it
    if (/[A-Z]/.test(floor) && /[a-z]/.test(unit)) {
      return `${floor}-${unit}` as StandardOfficeId;
    }

    // Return default if we can't standardize
    return this.DEFAULT_OFFICE_ID;
  }

  async findOptimalOffice(request: SchedulingRequest): Promise<SchedulingResult> {
    const log: string[] = [`Starting office assignment for request: ${JSON.stringify(request)}`];
    
    try {
      // 1. Get clinician details
      const clinician = this.clinicians.find(c => c.clinicianId === request.clinicianId);
      if (!clinician) {
        throw new Error(`Clinician ${request.clinicianId} not found`);
      }
      log.push(`Found clinician: ${clinician.name} (${clinician.role})`);

      // 2. Filter valid offices based on basic requirements
      const validOffices = this.filterValidOffices(request, clinician);
      log.push(`Found ${validOffices.length} initially valid offices`);

      if (validOffices.length === 0) {
        // If no valid offices found, attempt to use default office
        const defaultOffice = this.offices.find(o => 
          this.standardizeOfficeId(o.officeId) === this.DEFAULT_OFFICE_ID
        );

        if (defaultOffice && defaultOffice.inService) {
          log.push(`No specific matches found, using default office ${this.DEFAULT_OFFICE_ID}`);
          return {
            success: true,
            officeId: this.DEFAULT_OFFICE_ID,  // Now properly typed as StandardOfficeId
            notes: 'Assigned to default office (no specific matches)',
            evaluationLog: log
          };
        }

        return {
          success: false,
          error: 'No offices match requirements and default office unavailable',
          evaluationLog: log
        };
      }

      // 3. Score each valid office
      const scoredOffices: OfficeScore[] = [];
      
      for (const office of validOffices) {
        const score = await this.scoreOffice(office, request, clinician);
        scoredOffices.push(score);
        log.push(`Scored office ${office.officeId}: ${score.score} points`);
        log.push(...score.log);
      }

      // 4. Sort by score and check for hard matches
      const hardMatches = scoredOffices.filter(score => 
        score.reasons.some(reason => reason.startsWith('HARD:'))
      );

      const candidates = hardMatches.length > 0 ? hardMatches : scoredOffices;
      candidates.sort((a, b) => b.score - a.score);

      if (candidates.length === 0) {
        return {
          success: false,
          error: 'No suitable offices found after scoring',
          evaluationLog: log
        };
      }

      const bestMatch = candidates[0];
      const standardizedOfficeId = this.standardizeOfficeId(bestMatch.office.officeId);
      log.push(`Selected office ${standardizedOfficeId} with score ${bestMatch.score}`);
      log.push(`Assignment reasons: ${bestMatch.reasons.join(', ')}`);

      return {
        success: true,
        officeId: standardizedOfficeId,
        conflicts: bestMatch.conflicts,
        notes: bestMatch.reasons.join('; '),
        evaluationLog: [...log, ...bestMatch.log]
      };

    } catch (error) {
      log.push(`Error in office assignment: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        evaluationLog: log
      };
    }
  }

  private filterValidOffices(
    request: SchedulingRequest,
    clinician: SheetClinician
  ): SheetOffice[] {
    const log: string[] = [];
    
    return this.offices.filter(office => {
      // Check if office is in service
      if (!office.inService) {
        log.push(`Office ${office.officeId} filtered: not in service`);
        return false;
      }

      // Check accessibility requirements
      if (request.requirements?.accessibility && !office.isAccessible) {
        log.push(`Office ${office.officeId} filtered: accessibility requirements not met`);
        return false;
      }

      // Check clinician preferences - BUT don't exclude if they're the primary clinician
      if (office.primaryClinician !== clinician.clinicianId && 
          clinician.preferredOffices.length > 0 && 
          !clinician.preferredOffices.includes(office.officeId)) {
        log.push(`Office ${office.officeId} filtered: not in clinician's preferred offices`);
        return false;
      }

      // Check special features
      if (request.requirements?.specialFeatures?.length) {
        const hasAllFeatures = request.requirements.specialFeatures.every(
          feature => office.specialFeatures.includes(feature)
        );
        if (!hasAllFeatures) {
          log.push(`Office ${office.officeId} filtered: missing required features`);
          return false;
        }
      }

      // Check session type requirements
      if (request.sessionType === 'group' && 
          !office.specialFeatures.includes('group')) {
        log.push(`Office ${office.officeId} filtered: not suitable for group sessions`);
        return false;
      }

      return true;
    });
  }

  private async scoreOffice(
    office: SheetOffice,
    request: SchedulingRequest,
    clinician: SheetClinician
  ): Promise<OfficeScore> {
    const score: OfficeScore = {
      office,
      score: 0,
      reasons: [],
      conflicts: [],
      log: [`Starting evaluation for office ${office.officeId}`]
    };

    // 1. Check existing bookings and conflicts
    const existingBookings = this.existingBookings.get(office.officeId) || [];
    const timeConflicts = this.checkTimeConflicts(request, existingBookings);
    
    if (timeConflicts.length > 0) {
      score.log.push(`Found ${timeConflicts.length} time conflicts`);
      score.conflicts = timeConflicts;
      return score;
    }

    // 2. Apply base scoring
    
    // Primary clinician office gets highest base score
    if (office.primaryClinician === clinician.clinicianId) {
      score.score += 1000;
      score.reasons.push('HARD: Primary clinician office');
      score.log.push('Added 1000 points: Primary clinician office');
    }
    
    // Alternative clinicians get good but lower score
    else if (office.alternativeClinicians?.includes(clinician.clinicianId)) {
      score.score += 500;
      score.reasons.push('Alternative clinician office');
      score.log.push('Added 500 points: Alternative clinician office');
    }
    
    // Preferred office bonus
    if (clinician.preferredOffices.includes(office.officeId)) {
      score.score += 200;
      score.reasons.push('Clinician preferred office');
      score.log.push('Added 200 points: Clinician preferred office');
    }

    // 3. Apply rules in priority order
    const sortedRules = [...this.rules]
      .filter(rule => rule.active)
      .sort((a, b) => a.priority - b.priority);

    for (const rule of sortedRules) {
      const ruleScore = this.evaluateRule(rule, office, request, clinician);
      score.score += ruleScore.score;
      if (ruleScore.score > 0) {
        score.reasons.push(ruleScore.reason);
        score.log.push(...ruleScore.log);
      }
    }

    // 4. Apply client preferences if available
    if (this.clientPreference) {
      const prefScore = this.evaluateClientPreferences(office);
      score.score += prefScore.score;
      if (prefScore.score > 0) {
        score.reasons.push(...prefScore.reasons);
        score.log.push(...prefScore.log);
      }
    }

    // 5. Apply session type specific scoring
    const sessionScore = this.evaluateSessionType(office, request.sessionType);
    score.score += sessionScore.score;
    if (sessionScore.score > 0) {
      score.reasons.push(sessionScore.reason);
      score.log.push(...sessionScore.log);
    }

    score.log.push(`Final score for ${office.officeId}: ${score.score}`);
    return score;
  }

  private evaluateRule(
    rule: AssignmentRule,
    office: SheetOffice,
    request: SchedulingRequest,
    clinician: SheetClinician
  ): RuleEvaluationResult {
    const log: string[] = [`Evaluating rule: ${rule.ruleName}`];
    
    // Check if this rule applies to this office
    if (!rule.officeIds.includes(office.officeId)) {
      return { score: 0, reason: '', log: [`Rule ${rule.ruleName} doesn't apply to office ${office.officeId}`] };
    }

    switch (rule.ruleType) {
      case 'accessibility':
        if (request.requirements?.accessibility && office.isAccessible) {
          const score = rule.overrideLevel === 'hard' ? 1000 : 200;
          return {
            score,
            reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
            log: [`Added ${score} points for accessibility match`]
          };
        }
        break;

      case 'age_group':
        if (request.clientAge) {
          const condition = rule.condition;
          if (this.evaluateAgeCondition(condition, request.clientAge)) {
            const score = rule.overrideLevel === 'hard' ? 800 : 150;
            return {
              score,
              reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
              log: [`Added ${score} points for age group match`]
            };
          }
        }
        break;

      case 'session_type':
        if (request.sessionType === rule.condition) {
          const score = rule.overrideLevel === 'hard' ? 600 : 100;
          return {
            score,
            reason: rule.overrideLevel === 'hard' ? `HARD: ${rule.ruleName}` : rule.ruleName,
            log: [`Added ${score} points for session type match`]
          };
        }
        break;
    }

    return { score: 0, reason: '', log: [`No points added for rule ${rule.ruleName}`] };
  }

  private evaluateClientPreferences(office: SheetOffice): {
    score: number;
    reasons: string[];
    log: string[];
  } {
    const result = {
      score: 0,
      reasons: [] as string[],
      log: ['Evaluating client preferences']
    };

    if (!this.clientPreference) {
      result.log.push('No client preferences available');
      return result;
    }

    // Check previous office assignment
    if (this.clientPreference.assignedOffice === office.officeId) {
      const roomScore = (this.clientPreference.roomConsistency || 0) * 50;
      result.score += roomScore;
      result.reasons.push('Previous office match');
      result.log.push(`Added ${roomScore} points for previous office match`);
    }

    // Safely check mobility needs
    const mobilityNeeds = this.clientPreference.mobilityNeeds || [];
    if (Array.isArray(mobilityNeeds) && mobilityNeeds.length > 0 && office.isAccessible) {
      result.score += 300;
      result.reasons.push('Meets mobility needs');
      result.log.push('Added 300 points for mobility needs match');
    }

    // Safely check sensory preferences
    const sensoryPrefs = this.clientPreference.sensoryPreferences || [];
    if (Array.isArray(sensoryPrefs) && sensoryPrefs.length > 0) {
      const matchingSensory = sensoryPrefs.filter(
        pref => office.specialFeatures.includes(pref)
      );
      if (matchingSensory.length > 0) {
        const sensoryScore = matchingSensory.length * 50;
        result.score += sensoryScore;
        result.reasons.push('Matches sensory preferences');
        result.log.push(`Added ${sensoryScore} points for sensory preference matches`);
      }
    }

    return result;
  }

  private evaluateSessionType(
    office: SheetOffice,
    sessionType: string
  ): RuleEvaluationResult {
    switch (sessionType) {
      case 'group':
        if (office.specialFeatures.includes('group')) {
          return {
            score: 200,
            reason: 'Suitable for group sessions',
            log: ['Added 200 points for group session capability']
          };
        }
        break;

      case 'family':
        if (office.size === 'large') {
          return {
            score: 150,
            reason: 'Suitable size for family sessions',
            log: ['Added 150 points for family session size']
          };
        }
        break;
    }

    return { score: 0, reason: '', log: ['No specific session type points added'] };
  }

  private evaluateAgeCondition(condition: string, age: number): boolean {
    // Handle different age condition formats
    if (condition.includes('&&')) {
      const [minStr, maxStr] = condition.split('&&');
      const minAge = parseInt(minStr.split('>')[1].trim());
      const maxAge = parseInt(maxStr.split('<=')[1].trim());
      return age > minAge && age <= maxAge;
    }
    
    if (condition.includes('<=')) {
      const maxAge = parseInt(condition.split('<=')[1].trim());
      return age <= maxAge;
    }
    
    if (condition.includes('>=')) {
      const minAge = parseInt(condition.split('>=')[1].trim());
      return age >= minAge;
    }

    return false;
  }

  private checkTimeConflicts(
    request: SchedulingRequest,
    existingBookings: SchedulingRequest[]
  ): SchedulingConflict[] {
    const conflicts: SchedulingConflict[] = [];
    const requestStart = new Date(request.dateTime);
    const requestEnd = new Date(requestStart.getTime() + (request.duration * 60 * 1000));

    existingBookings.forEach(booking => {
      const bookingStart = new Date(booking.dateTime);
      const bookingEnd = new Date(bookingStart.getTime() + (booking.duration * 60 * 1000));

      if (requestStart < bookingEnd && requestEnd > bookingStart) {
        conflicts.push({
          officeId: this.standardizeOfficeId(request.clinicianId),
          existingBooking: booking,
          resolution: {
            type: 'cannot-relocate',
            reason: 'Time slot overlap with existing booking'
          }
        });
      }
    });

    return conflicts;
  }
}